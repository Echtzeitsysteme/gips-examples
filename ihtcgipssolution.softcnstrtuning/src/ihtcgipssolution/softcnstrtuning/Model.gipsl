package "ihtcgipssolution.softcnstrtuning"
import "platform:/resource/ihtcmetamodel/model/Ihtcmetamodel.ecore"
config {  
	solver := GUROBI;
	timeLimit := true [value := 590.0, includeInitTime := true];
	randomSeed := true [value := 7];
	presolve := true;
	debugOutput := false;
	lpOutput := true [path := "gurobi.lp"];
	threadCount := true [value := 4];
}
rule assignNurseToRoomShift {
	h : Hospital {
		- nurses -> n
		- shifts -> s
		- rooms -> r
	}
	n : Nurse {
		- shiftMaxLoads -> sml
	}
	s : Shift
	r : Room
	++ rsna : RoomShiftNurseAssignment {
		++ - nurse -> n
		++ - shift -> s
		++ - room -> r
	}
	sml : NurseShiftMaxLoad {
		- shift -> s
	}
	# sml.maxLoad > 0
}
rule assignAdmissionDayToPatient {
	h : Hospital {
		- patients -> p
		- days -> d
	}
	p : Patient {
		++ - admissionDay -> d
	}
	d : Day
	# p.surgeryReleaseDay <= d.id
	# p.surgeryDueDate >= d.id
}
pattern roomPatientIncompatible {
	h : Hospital {
		- patients -> p
		- rooms -> r
	}
	p : Patient {
		- incompatibleRooms -> r
	}
	r : Room
}
condition roomNotIncompatible = forbid roomPatientIncompatible
rule assignRoomToPatient {
	h : Hospital {
		- patients -> p
		- rooms -> r
	}
	p : Patient {
		++ - assignedRoom -> r
	}
	r : Room
}
when roomNotIncompatible
rule assignSurgeryToPatient {
	h : Hospital {
		- patients -> p
		- surgeons -> s
		- days -> d
		- operatingTheaters -> ot
	}
	p : Patient {
		++ - surgeryAssignment -> sa
		- surgeon -> s
	}
	s : Surgeon {
		- availabilities -> as
	}
	d : Day
	ot : OperatingTheater {
		- availabilities -> aot
	}
	++ sa : SurgeryAssignment {
		++ - patient -> p
		++ - surgeon -> s
		++ - operationTheater -> ot
		++ - day -> d
	}
	aot : OperatingTheaterAvailability {
		- day -> d
	}
	# aot.availability > 0
	as : SurgeonAvailability {
		- day -> d
	}
	# as.availability > 0
}
pattern dayRoomTuple {
	h : Hospital {
		- days -> d
		- rooms -> r
	}
	d : Day
	r : Room
}
pattern daySurgeonTuple {
	h : Hospital {
		- days -> d
		- surgeons -> s	
	}
	d : Day
	s : Surgeon
}
pattern dayOperatingTheaterAvailabilityTriple {
	h : Hospital {
		- days -> d
		- operatingTheaters -> ot
	}
	d : Day
	
	ot : OperatingTheater {
		- availabilities -> aot
	}
	aot : OperatingTheaterAvailability
	# aot.availability > 0
}
pattern dayOperatingTheaterTuple {
	h : Hospital {
		- days -> d
		- operatingTheaters -> ot
	}
	d : Day
	ot : OperatingTheater
}
pattern findMandatoryPatient {
	h : Hospital {
		- patients -> p
	}
	p : Patient
	# p.mandatory == true
}
pattern findOptionalPatient {
	h : Hospital {
		- patients -> p
	}
	p : Patient
	# p.mandatory == false
}
pattern dayPatientTuple {
	h : Hospital {
		- patients -> p
		- days -> d
	}
	p : Patient
	d : Day
	# p.surgeryReleaseDay <= d.id
	# p.surgeryDueDate + p.lengthOfStay - 1 >= d.id
}
pattern roomShiftTuple {
	h : Hospital {
		- rooms -> r
		- shifts -> s
	}
	r : Room
	s : Shift
}
pattern patientRoomDay {
	h : Hospital {
		- rooms -> r
		- patients -> p
		- days -> d
	}
	r : Room
	p : Patient
	d : Day
	# p.surgeryReleaseDay <= d.id
	# p.surgeryDueDate + p.lengthOfStay - 1 >= d.id
}
pattern occupantRoomDay {
	h : Hospital {
		- rooms -> r
		- occupants -> o
		- days -> d
	}
	r : Room
	o : Occupant
	d : Day
	# r.name == o.roomId
	# o.lengthOfStay >= d.id
}
pattern dayRoomGender {
	h : Hospital {
		- days -> d
		- rooms -> r
		- genders -> g
	}
	d : Day
	r : Room
	g : Gender
}
mapping anrs to assignNurseToRoomShift;
mapping aadp to assignAdmissionDayToPatient;
mapping arp to assignRoomToPatient;
mapping asp to assignSurgeryToPatient;
mapping roomDayPatientLoad to patientRoomDay;
mapping roomDayLoad to dayRoomTuple {
	var load : EInt
};
mapping roomDayGender to dayRoomGender;
mapping otDayOpened to dayOperatingTheaterTuple;
constraint with otDayOpened {
	mappings.asp->filter(element.nodes.d == context.nodes.d & element.nodes.ot == context.nodes.ot)->sum(element.value)
	<=
	1000 * context.value
	&
	mappings.asp->filter(element.nodes.d == context.nodes.d & element.nodes.ot == context.nodes.ot)->sum(element.value)
	>=
	context.value
}
constraint with roomDayGender {
	mappings.roomDayPatientLoad->filter( //
		element.nodes.d == context.nodes.d //
		& element.nodes.r == context.nodes.r //
		& element.nodes.p.gender == context.nodes.g.name //
	)->sum(element.value)
	+
	patterns.occupantRoomDay->filter( //
		element.nodes.d == context.nodes.d //
		& element.nodes.r == context.nodes.r //
		& element.nodes.o.gender == context.nodes.g.name //
	)->sum(1)
	<=
	1000 * context.value
	&
	mappings.roomDayPatientLoad->filter( //
		element.nodes.d == context.nodes.d //
		& element.nodes.r == context.nodes.r //
		& element.nodes.p.gender == context.nodes.g.name //
	)->sum(element.value)
	+
	patterns.occupantRoomDay->filter( //
		element.nodes.d == context.nodes.d //
		& element.nodes.r == context.nodes.r //
		& element.nodes.o.gender == context.nodes.g.name //
	)->sum(1)
	>=
	context.value
}
constraint with roomDayPatientLoad {
	mappings.aadp->filter( //
		element.nodes.p == context.nodes.p //
		& element.nodes.d.id - 1 <= context.nodes.d.id //
		& element.nodes.d.id + context.nodes.p.lengthOfStay - 1 >= context.nodes.d.id //
	)->sum(element.value)
	+
	mappings.arp->filter( //
		element.nodes.p == context.nodes.p //
		& element.nodes.r == context.nodes.r //
	)->sum(element.value)
	- 1
	<=
	context.value
	&
	mappings.aadp->filter( //
		element.nodes.p == context.nodes.p //
		& element.nodes.d.id - 1 <= context.nodes.d.id //
		& element.nodes.d.id + context.nodes.p.lengthOfStay - 1 >= context.nodes.d.id //
	)->sum(element.value)
	>=
	context.value
	&
	mappings.arp->filter( //
		element.nodes.p == context.nodes.p //
		& element.nodes.r == context.nodes.r //
	)->sum(element.value)
	>=
	context.value
}
constraint with roomDayLoad {
	context.variables.load
	==
	mappings.roomDayPatientLoad->filter( //
		element.nodes.r == context.nodes.r //
		& element.nodes.d == context.nodes.d //
	)->sum(element.value)
	+
	patterns.occupantRoomDay->filter(element.nodes.r == context.nodes.r & element.nodes.d == context.nodes.d)->sum(1)
}
constraint with dayRoomTuple {
	mappings.roomDayGender->filter(
		element.nodes.r == context.nodes.r //
		& element.nodes.d == context.nodes.d //	
	)->sum(element.value)
	<=
	1
}
constraint with roomDayLoad {
	context.variables.load <= context.nodes.r.capacity
}
constraint with daySurgeonTuple {
	mappings.asp->filter( //
		element.nodes.d == context.nodes.d //
		& element.nodes.s == context.nodes.s
	)->sum(element.nodes.p.surgeryDuration * element.value)
	<=
	context.nodes.s.availabilities->filter(element.day == context.nodes.d)->sum(element.availability)
}
constraint with dayOperatingTheaterAvailabilityTriple {
	mappings.asp->filter( //
		element.nodes.d == context.nodes.d //
		& element.nodes.ot == context.nodes.ot //
	)->sum(element.nodes.p.surgeryDuration * element.value)
	<=
	context.nodes.ot.availabilities->filter(element.day == context.nodes.d)->sum(element.availability)
}
constraint with findMandatoryPatient {
	mappings.aadp->filter(element.nodes.p == context.nodes.p)->sum(element.value) == 1
	&
	mappings.arp->filter(element.nodes.p == context.nodes.p)->sum(element.value) == 1
}
constraint with findOptionalPatient {
	mappings.aadp->filter(element.nodes.p == context.nodes.p)->sum(element.value) <= 1
	&
	mappings.arp->filter(element.nodes.p == context.nodes.p)->sum(element.value) <= 1
	&
	mappings.aadp->filter(element.nodes.p == context.nodes.p)->sum(element.value)
	==
	mappings.arp->filter(element.nodes.p == context.nodes.p)->sum(element.value)
}
constraint with findMandatoryPatient {
	mappings.aadp->filter( //
		element.nodes.p == context.nodes.p //
	)->sum(element.value)
	== 1
}
constraint with Patient {
	mappings.arp->filter(element.nodes.p == context)->sum(element.value) <= 1
}
constraint with dayPatientTuple {
	mappings.aadp->filter(element.nodes.p == context.nodes.p & element.nodes.d == context.nodes.d)->sum(element.value)
	==
	mappings.asp->filter(element.nodes.p == context.nodes.p & element.nodes.d == context.nodes.d)->sum(element.value)
}
constraint with roomShiftTuple {
	mappings.anrs->filter(element.nodes.r == context.nodes.r & element.nodes.s == context.nodes.s)->sum(element.value)
	<= 1
}
constraint with roomShiftTuple {
	mappings.roomDayLoad->filter( //
		element.nodes.r == context.nodes.r //
		& element.nodes.d == context.nodes.s.day //
	)->sum(element.variables.load)
	<=
	mappings.anrs->filter(element.nodes.r == context.nodes.r & element.nodes.s == context.nodes.s)->sum(element.value)
	*
	1000
}
function electiveUnscheduledPatients with findOptionalPatient {
	1 - mappings.aadp->filter(element.nodes.p == context.nodes.p)->sum(element.value)
}
function admissionDelay with aadp {
	(context.nodes.d.id - context.nodes.p.surgeryReleaseDay) * context.value
}
function openOts with otDayOpened {
	context.value
}
objective : min {
	0
	+ functions.electiveUnscheduledPatients * types.Weight->sum(element.unscheduledOptional)
	+ functions.admissionDelay * types.Weight->sum(element.patientDelay)
	+ functions.openOts * types.Weight->sum(element.openOperatingTheater)
}