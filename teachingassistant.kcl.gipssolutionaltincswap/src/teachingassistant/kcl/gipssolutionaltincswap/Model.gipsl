package "teachingassistant.kcl.gipssolutionaltincswap"
import "platform:/resource/teachingassistant.kcl.metamodelalt/model/Metamodelalt.ecore"

config {  
	solver := GUROBI;
	timeLimit := true [value := 120.0];
	randomSeed := true [value := 0];
	presolve := true;
	debugOutput := true;
	lpOutput := false [path := "problem.lp"];
}

//
// GT
//

// Finds a TA with the name `taA` that is unavailable in
// a TimeTableEntry with name `entryA`.
pattern findTaAUnavailableEntryA {	
	taA : TA {
		- unavailable_because_lessons -> entryA
	}
	
	entryA : TimeTableEntry
}

// Finds a TA with the name `taB` that is unavailable in
// a TimeTableEntry with name `entryB`.
pattern findTaAUnavailableEntryB {
	taA : TA {
		- unavailable_because_lessons -> entryB
	}
	
	entryB : TimeTableEntry
}

// Finds a TA with the name `taB` that is unavailable in
// a TimeTableEntry with name `entryA`.
pattern findTaBUnavailableEntryA {
	taB : TA {
		- unavailable_because_lessons -> entryA
	}
	
	entryA : TimeTableEntry
}

// Composition condition for the swap GT rule:
// - TA_A must be blocked in entry A
// - TA_A must be available (i.e., not blocked) in entry B
// - TA_B must be available (i.e., not blocked) in entry A
condition taAandTaBAllCondition = enforce findTaAUnavailableEntryA && forbid findTaAUnavailableEntryB && forbid findTaBUnavailableEntryA

// Rule to swap two TAs for a specific session occurrence.
// This rule only matches if the first TA (`taA`) has a conflict.
// I.e., this rule should fix a violated assignment of a TA by swapping
// two assignments.
rule swapTas {
	taA : TA
	taB : TA
	
	sessionA : TeachingSession {
		- occurrences -> occurrenceA
		- entries -> entryA
	}
	
	sessionB : TeachingSession {
		- occurrences -> occurrenceB
		- entries -> entryB
	}
	
	occurrenceA : SessionOccurrence {
		-- - tas -> taA
		++ - tas -> taB
	}
	
	occurrenceB : SessionOccurrence {
		-- - tas -> taB
		++ - tas -> taA
	}
	
	wA : Week
	wB : Week
	
	entryA : TimeTableEntry {
		- timeTableWeeks -> wA
	}
	
	entryB : TimeTableEntry {
		- timeTableWeeks -> wB
	}
	
	# occurrenceA.timeTableWeek == wA.number
	# occurrenceB.timeTableWeek == wB.number
}
when taAandTaBAllCondition

// For a specific TA, find all conflicting time table
// entries in the model.
// This pattern does respect partly overlapping time
// table entries.
pattern findConflictingEntriesWithTa {
	root : TAAllocation {
		- timetable -> entryA
		- timetable -> entryB
		- weeks -> week
		- tas -> ta
	}
	
	week : Week
	
	entryA : TimeTableEntry {
		- timeTableWeeks -> week
	}
	entryB : TimeTableEntry {
		- timeTableWeeks -> week
	}
	
	ta : TA
	
	# entryA.startEpoch < entryB.endEpoch
	# entryA.endEpoch > entryB.startEpoch
}

// Find all possible combinations of TAs and weeks
pattern findTaWeekCombination {
	root : TAAllocation {
		- weeks -> w
		- tas -> ta
	}
	
	w : Week
	ta : TA
}

// Construct a condition for a session that a specific TA
// is available (i.e., they have not blocked this session)
pattern findTaUnavailableSession {
	ta : TA {
		- unavailable_because_lessons -> entry
	}
	
	entry : TimeTableEntry
}
condition taBlockedInSession = enforce findTaUnavailableSession

// Finds a blocked TA with a corresponding session occurrence.
pattern findBlockedTa {
	root : TAAllocation {
		- tas -> ta
		- modules -> module
	}
	
	ta : TA
	
	module : Module {
		- sessions -> session
	}
	
	session : TeachingSession {
		- occurrences -> occurrence
		- entries -> entry
	}
	
	occurrence : SessionOccurrence {
		- tas -> ta
	}
	
	w : Week
	
	entry : TimeTableEntry {
		- timeTableWeeks -> w
	}
	
	# occurrence.timeTableWeek == w.number
}
when taBlockedInSession

// Pattern to find an existing TA assignment.
pattern taExistingAssignment {
	root : TAAllocation {
		- tas -> ta
		- modules -> module
	}
	
	ta : TA
	
	module : Module {
		- sessions -> session
	}
	
	session : TeachingSession {
		- occurrences -> occurrence
		- entries -> entry
	}
	
	occurrence : SessionOccurrence {
		- tas -> ta
	}
	
	w : Week
	
	entry : TimeTableEntry {
		- timeTableWeeks -> w
	}
	
	# occurrence.timeTableWeek == w.number
}

//
// GIPSL
//

// Mapping that is `true` if a specific match of the swap GT rule
// must be applied.
mapping swap to swapTas;

// Every blocked TA must be swapped out
constraint with findBlockedTa {
	mappings.swap->filter( //
		element.nodes.occurrenceA == context.nodes.occurrence //
		& element.nodes.taA == context.nodes.ta //
	)->sum(element.value)
	==
	1
}

// TAs must not have conflicting assignments.
// GIPSL formulation: For any pair of conflicting session occurrences (in the
// context of one TA), a maximum of one of these conflicting session can be chosen.
constraint with findConflictingEntriesWithTa {
	// No conflict for TA_B between multiple swaps
	mappings.swap->filter(element.nodes.taB == context.nodes.ta & element.nodes.entryA == context.nodes.entryA)->sum(element.value)
	+
	mappings.swap->filter(element.nodes.taB == context.nodes.ta & element.nodes.entryA == context.nodes.entryB)->sum(element.value)
	<= 1
	
	&
	
	// No conflict for TA_A between multiple swaps
	mappings.swap->filter(element.nodes.taA == context.nodes.ta & element.nodes.entryB == context.nodes.entryA)->sum(element.value)
	+
	mappings.swap->filter(element.nodes.taA == context.nodes.ta & element.nodes.entryB == context.nodes.entryB)->sum(element.value)
	<= 1
	
	&
	
	// No conflict for TA_A between a swap and an existing assignment
	mappings.swap->filter(element.nodes.taA == context.nodes.ta & element.nodes.entryB == context.nodes.entryB)->sum(element.value)
	+
	patterns.taExistingAssignment->filter(element.nodes.ta == context.nodes.ta & element.nodes.entry == context.nodes.entryB)->sum(1)
	<= 1
	
	&
	
	// No conflict for TA_B between a swap and an existing assignment
	mappings.swap->filter(element.nodes.taB == context.nodes.ta & element.nodes.entryA == context.nodes.entryA)->sum(element.value)
	+
	patterns.taExistingAssignment->filter(element.nodes.ta == context.nodes.ta & element.nodes.entry == context.nodes.entryA)->sum(1)
	<= 1
}

// Ensure TAs max hours per year
// GIPSL interpretation: the sum of all assigned working hours per TA
// must not exceed their yearly hour limit
constraint with TA {
	mappings.swap->filter( //
		element.nodes.taA == context //
	)->sum( //
		element.value * element.nodes.sessionB.hoursPaidPerOccurrence //
		- element.value * element.nodes.sessionA.hoursPaidPerOccurrence //
	)
	+ patterns.taExistingAssignment->filter( //
		element.nodes.ta == context //
	)->sum(element.nodes.session.hoursPaidPerOccurrence)
	<= context.maxHoursPerYear
	
	&
	
	mappings.swap->filter( //
		element.nodes.taB == context //
	)->sum( //
		element.value * element.nodes.sessionA.hoursPaidPerOccurrence //
		- element.value * element.nodes.sessionB.hoursPaidPerOccurrence //
	)
	+ patterns.taExistingAssignment->filter( //
		element.nodes.ta == context //
	)->sum(element.nodes.session.hoursPaidPerOccurrence)
	<= context.maxHoursPerYear
}

// Ensure TAs max hours per week
// GIPSL interpretation: the sum of all assigned working hours per TA
// in a specific week must not exceed their weekly hour limit
constraint with findTaWeekCombination {
	mappings.swap->filter( //
		element.nodes.taA == context.nodes.ta //
		& element.nodes.wA == context.nodes.w
	)->sum( //
		element.value * element.nodes.sessionB.hoursPaidPerOccurrence //
		- element.value * element.nodes.sessionA.hoursPaidPerOccurrence //
	)
	+ patterns.taExistingAssignment->filter( //
		element.nodes.ta == context //
		& element.nodes.w == context.nodes.w //
	)->sum(element.nodes.session.hoursPaidPerOccurrence)
	<= context.nodes.ta.maxHoursPerWeek
	
	&
	
	mappings.swap->filter( //
		element.nodes.taB == context.nodes.ta //
		& element.nodes.wB == context.nodes.w
	)->sum( //
		element.value * element.nodes.sessionA.hoursPaidPerOccurrence //
		- element.value * element.nodes.sessionB.hoursPaidPerOccurrence //
	)
	+ patterns.taExistingAssignment->filter( //
		element.nodes.ta == context //
		& element.nodes.w == context.nodes.w //
	)->sum(element.nodes.session.hoursPaidPerOccurrence)
	<= context.nodes.ta.maxHoursPerWeek
}
