package "org.emoflon.gips.gipsl.examples.lsp2p.gipsl.batch"

import "platform:/resource/LectureStudioModel/model/LectureStudioModel.ecore"
import "http://www.eclipse.org/emf/2002/Ecore"

config {
	solver := GUROBI [home:="c:\gurobi1000\win64", license:="c:\gurobi1000\win64\gurobi.lic"];
	launchConfig := true [main := "org.emoflon.gips.gipsl.examples.lsp2p.run.LSp2pBatch"];
	timeLimit := true [value := 6000.0];
	randomSeed := true [value := 0];
	presolve := true;
	debugOutput := true;
	tolerance := true [value := 0.000001];
}

condition clientIsWaiting = enforce ls2client
pattern ls2client {
	ls : LectureStudioServer {
		-waitingClients->client
	}
	client : Client
}

rule addClient(hasRoot: EInt, bw: EDouble, tt: EDouble) {
	relay : Node {
		++ -clientConnection->connection
		++ -activeClients->client
		.isRelayClient := 1
	}
	
	client : Client {
		.transferTime := param::tt
		.isHasRoot := param::hasRoot
	}
	
	++ connection : Connection { 
		++ -server-> relay
		++ -client-> client
		.transferRate := param::bw
	}
	
	# relay.txBW > client.txBW
} when clientIsWaiting

rule node(abw: EDouble) {
	node : Node {
		.allocatedTxBW := param::abw
	} 
}

mapping ac with addClient {
	var hasRoot:EInt bind hasRoot					// Zeigt an, ob es eine Verbindung zum LS Server gibt.
	var connectionBW:EDouble bind bw	// Gibt an wie viel BW für Client reserviert wird.
	var transferTime:EDouble bind tt	// Gibt die Zeit an, die es braucht um das File bis zum Client zu transportieren.
};

mapping nde with node {
	var allocatedBW:EDouble	bind abw			// Gibt die gesamte Upload-BW Auslastung aus sich eines (Relay) Clients an.
};

/*	Setzt die Konfluenzbedingung für die Einbettung: Es darf maximal und es muss mindestens eine Mappingvariable ausgewählt werden.	
 */
constraint -> pattern::ls2client {
	mappings.ac->filter(m | m.nodes().client == self.nodes().client)->sum(m | m.value()) == 1
}


/*	Setzt die Randbedingungen für die Belegungsvariable und die hasRoot-Hilfsvariable:
 * 	self.value():	Darf nur 1 sein, wenn es eine direkte oder indirekte Verbindung zum LS Server gibt und umgekehrt.
 * 					Muss 0 sein, wenn es keine direkte oder indirekte Verbindung zum LS Server und umgekehrt.
 *  hasRoot:		Darf nur zwischen 0 und 1 liegen, darf nur 1 sein, wenn self.value() 1 ist und umgekehrt.
 * 					Muss 1 sein, wenn eine direkte Verbindung zum LS Server besteht.	
 */
//constraint -> mapping::ac {
//	[self.value() >= 1 <=> self.variables().hasRoot >= 1] &
//	[self.value() <= 0 <=> self.variables().hasRoot <= 0] &
//	self.variables().hasRoot >= 0 &
//	self.variables().hasRoot <= 1 //&
//	// Das tut irgendwie nicht. Wir muessen irgendwie eine Moeglichkeit einbauen um Anfangswerte fuer Variablen zu setzen.
//	//self.variables().hasRoot >= classes.LectureStudioServer->filter(m | m.id == self.nodes().relay.id )->count()
//	//self.variables().hasRoot >= self.nodes().relay.isLsServer
//}

/*	Setzt die positive Randbedingung für die hasRoot Variable:
 * 	hasRoot:		Muss 1 sein, wenn es eine indirekte Verbindung zum LS Server gibt.	
 */
//constraint -> pattern::addClient {
//	mappings.ac->filter(m | m.nodes().client == self.nodes().client & m.nodes().relay == self.nodes().relay)->sum(m | m.variables().hasRoot) >= 1 <=>
//	[mappings.ac->filter(m | m.nodes().client == self.nodes().relay)->sum(m | m.variables().hasRoot) >= 1 |
//	self.nodes().relay.isHasRoot >= 1]
//}

/*	Setzt die negative Randbedingung für die hasRoot Variable:
 * 	hasRoot:		Muss 0 sein, wenn es weder eine indirekte Verbindung noch eine direkte Verbindung zum LS Server gibt.	
 */
//constraint -> pattern::addClient {
//	mappings.ac->filter(m | m.nodes().client == self.nodes().client & m.nodes().relay == self.nodes().relay)->sum(m | m.variables().hasRoot) <= 0 <=>
//	[mappings.ac->filter(m | m.nodes().client == self.nodes().relay)->sum(m | m.variables().hasRoot) <= 0 &
//	self.nodes().relay.isHasRoot <= 0]
//}

/*	Setzt die Randbedingungen für die Belegungsvariable und die connectionBW-Hilfsvariable:
 * 	self.value():	Darf nur 1 sein, wenn Bandbreite allokiert wird und umgekehrt.
 * 					Muss 0 sein, wenn es keine Bandbreite allokiert wird und umgekehrt.
 *  connectionBW:	Muss positiv sein.	
 */
constraint -> mapping::ac {
	[self.value() >= 1 <=> self.variables().connectionBW >= 1.0/self.nodes().client.residualRxBW] &
	[self.value() <= 0 <=> self.variables().connectionBW <= 0]
}

/*	Setzt die Randbedingungen für die Belegungsvariable und die connectionBW-Hilfsvariable:
 * 	self.value():	Darf nur 1 sein, wenn Sende-Bandbreite allokiert wird und umgekehrt.
 * 					Muss 0 sein, wenn es keine Sende-Bandbreite Bandbreite allokiert wird und umgekehrt.
 *  allocatedBW:	Muss positiv und nicht größer als die noch verfügbare txBW sein.
 */
constraint -> mapping::nde {
	[self.value() >= 1 <=> self.variables().allocatedBW >= 1.0/self.nodes().node.residualTxBW] &
	[self.value() >= 1 <=> self.variables().allocatedBW <= 1.0/self.nodes().node.residualTxBW] &
	[self.value() <= 0 <=> self.variables().allocatedBW <= 0]
	//& [self.variables().allocatedBW >= 0.0001 <=> self.variables().allocatedBW <= 1.0/self.nodes().node.residualTxBW]
}

/*	Setzt die allokierte Sendebandbreite auf die Summe aller reservierten Teilbandbreiten.
 * 	Hier wird auch die Mapping-Variable von nde indirekt an die Mapping-Variable von ac gekoppelt. 
 */
constraint -> pattern::node {
	mappings.nde->filter(m | m.nodes().node == self.nodes().node)->sum(m | m.variables().allocatedBW * m.nodes().node.data) == 
	mappings.ac->filter(m | m.nodes().relay == self.nodes().node)->sum(m | m.variables().transferTime)
}

/*	Setzt die Randbedingungen für die transferTime-Hilfsvariable:
 *  connectionBW:	Muss positiv sein.	
 */
constraint -> mapping::ac {
	[self.value() >= 1 <=> self.variables().transferTime >= 0.0001] &
	[self.value() <= 0 <=> self.variables().transferTime <= 0]
}

/*	Setzt den transfertTime Wert auf die Summe aus der Zeit die es zwischen Relay zu Client braucht und die Zeit, die es von Root (LS) zum Relay bräuchte.
 * 	Notiz: 	Eigentlich müsste man sich die Datengröße vom Server holen. Das geht hier leider nicht, da die arithmetische Umformung so explodiert. 
 * 			Dann sagt halt eben der Requester jetzt wie groß der Request ist. Ist ja wumms, so lange die Dateien alle gleich groß sind.
 */
constraint -> pattern::addClient {
	mappings.ac->filter(m | m.nodes().relay == self.nodes().relay & m.nodes().client == self.nodes().client)->sum(m | m.variables().transferTime) == 
	mappings.ac->filter(m | m.nodes().relay == self.nodes().relay & m.nodes().client == self.nodes().client)->sum(m | m.variables().connectionBW * m.nodes().client.data)  
	+ mappings.ac->filter(m | m.nodes().client == self.nodes().relay)->sum(m | m.variables().transferTime)  
}

// Besser wäre es, das eigentlich auch über Jain's Fairness index zu machen. So können manche Clients zum Wohle aller extrem benachteiligt werden.
objective transfertime -> mapping::ac {
	self.variables().transferTime
}

global objective : min {
	transfertime
}
