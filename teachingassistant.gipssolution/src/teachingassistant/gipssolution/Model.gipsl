package "teachingassistant.gipssolution"
import "platform:/resource/teachingassistant.metamodel/model/Metamodel.ecore"

config {  
	solver := GUROBI [home:="fu", license:="bar"];
	launchConfig := true [main := "TODO"];
	timeLimit := true [value := 120.0];
	randomSeed := true [value := 0];
	presolve := true;
	debugOutput := true;
}

rule assignAssistantToTutorial {
	a : Assistant {
		- skills -> s
	}
	
	t : Tutorial {
		++ -givenBy -> a
	}
	
	d : Department {
		- assistants -> a
		- tutorials -> t
	}
	
	s : Skill
	
	// SkillType must match
	# t.type == s.type
	
	// preference must be at least 1
	# s.preference >= 1
}

pattern findTutorial {
	t : Tutorial
}

pattern findAssistant {
	a : Assistant
}

pattern findAssistantTutorialTriple {
	a : Assistant
	t1 : Tutorial {
		- timeslot -> ts
	}
	t2 : Tutorial {
		- timeslot -> ts
	}
	ts : Timeslot
}

mapping at with assignAssistantToTutorial;

// Every tutorial must be given exactly once
constraint -> pattern::findTutorial {
	mappings.at->filter(m | m.nodes().t == self.nodes().t)->count() == 1
}

// The duration of all assignments for every assistant must lay
// in their valid hour interval (min <= assignments <= max)
constraint -> pattern::findAssistant {
	mappings.at->filter(m | m.nodes().a == self.nodes().a)->sum(m | m.nodes().t.duration) >= self.nodes().a.minimumHoursPerWeek
	&
	mappings.at->filter(m | m.nodes().a == self.nodes().a)->sum(m | m.nodes().t.duration) <= self.nodes().a.maximumHoursPerWeek
}

// M1: An assistant must not have two tutorials in the same time slot
// Formulation in GIPSL: for a given triple of an Assistant (a) and two
// conflicting tutorials (t1, t2; conflicting means they both have the 
// same time slot) there must at most be one of the tutorials chosen
constraint -> pattern::findAssistantTutorialTriple {
	mappings.at->filter(m | m.nodes().a == self.nodes().a & m.nodes().t == self.nodes().t1)->count()
	+
	mappings.at->filter(m | m.nodes().a == self.nodes().a & m.nodes().t == self.nodes().t2)->count()
	<= 1
}