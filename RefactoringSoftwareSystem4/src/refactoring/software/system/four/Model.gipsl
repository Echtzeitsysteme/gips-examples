package "refactoring.software.system.four"
import "platform:/resource/SoftwareSystem/model/softwareSystem.ecore"

config {  
	solver := GLPK [home:="fu", license:="bar"];
	timeLimit := true [value := 120.0];
	randomSeed := true [value := 0];
	presolve := true;
	debugOutput := true;
	tolerance := true [value := 0.00001];
}

// Minimize number of matches for this pattern (coupling)
pattern cps {
	s : System {
		-components -> c
	}
	c : Component
	
	s2 : System {
		-components -> c2
	}
	c2 : Component {
		-imports -> c
	}
}

// Maximize number of matches for this pattern (cohesion)
pattern chs {
	s : System {
		-components -> c
		-components -> c2
	}
	c : Component {
		-imports -> c3
	}
	c2 : Component {
		-imports -> c3
	}
	c3 : Component
}


// Removes the `components` edge from a `System` to a `Component`.
// This rule must be executed for every match before creating a new structure.
rule removeComponentsEdge {
	c: Component
	s: System {
		-- -components -> c
	}
}

mapping removePreexistingEdges with removeComponentsEdge;

// Every match of the rule `removeComponentsEdge` must be selected
constraint -> mapping::removePreexistingEdges {
	self.value() == 1
}

rule addComponentToSystem {
	c: Component
	s: System {
		++ -components -> c
	}
}
pattern findTwoComponents {
	c1: Component
	c2: Component {
		-imports -> c1
	}
}

mapping addCtoS with addComponentToSystem;

// Every component must be contained in a system
//constraint -> mapping::addCtoS {
//	self.value() == 1
//}
constraint -> class::Component {
	mappings.addCtoS->filter(m | m.nodes().c == self)->sum(m | m.value()) == 1
}

//objective cps -> pattern::addComponentToSystem {
//	mappings.addCtoS->filter(m | m.nodes().s == self.)
//}
//objective cps -> pattern::findTwoComponents {
//	mappings.addCtoS->filter()
//}
//constraint -> pattern::findTwoComponents {
//	mappings.addCtoS->filter(m | m.nodes().c == self.nodes().c1)->
//}

//objective chs -> pattern::addComponentToSystem {
//// TODO
//	1
//}

global objective : max {
//	-(cps) + chs
	1
}
