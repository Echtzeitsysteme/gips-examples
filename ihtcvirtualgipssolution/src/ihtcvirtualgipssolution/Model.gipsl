package "ihtcvirtualgipssolution"
import "platform:/resource/ihtcvirtualmetamodel/model/Ihtcvirtualmetamodel.ecore"

config {  
	solver := GUROBI;
	timeLimit := true [value := 30.0];
	randomSeed := true [value := 0];
	presolve := true;
	debugOutput := true;
}

//
// GT
//

// Rule that selects a VirtualShiftToWorkload-Node to be adopted in the final model. 
rule selectShiftToFirstWorkload {
	root : Root {
		- patients -> p
		- virtualShiftToWorkload -> vsw 
	}
	
	p : Patient {
		- firstWorkload -> w
	}
	
	w : Workload {
		- virtualShift -> vsw
		- virtualCapacity -> vwc
	}
	
	vwc : VirtualWorkloadToCapacity {
		- capacity -> c
	}
	
	vsw : VirtualShiftToWorkload {
		- shift -> s
		- requires_virtualWorkloadToCapacity -> vwc
		.isSelected := true
	}
	
	s : Shift {
		- room -> r
	}
	
	r : Room
	
	c : Capacity
	
	// Already expected in preprocessing. Not mandatory here
	# s.shiftNo / 3 == c.day 
	# s.shiftNo % 3 == 0
}

// Rule that selects an extending VirtualShiftToWorkload-Node to be adopted in the final model. 
rule selectExtendingShiftToFirstWorkload {
	root : Root {
		- patients -> p
		- virtualShiftToWorkload -> prevvsw
		- virtualShiftToWorkload -> nextvsw
		- rooms -> r
	}
	
	p : Patient {
		- workloads -> prevw
	}
	
	prevw : Workload {
		- next -> nextw
	}
	
	nextw : Workload
	
	prevvsw : VirtualShiftToWorkload {
		- workload -> prevw
		- shift -> prevs
		- enables_virtualShiftToWorkload -> nextvsw
	}
	
	prevs : Shift {
		- next -> nexts
		- room -> r
	}
	
	nexts : Shift {
		- room -> r
	}
	
	r : Room
	
	nextvsw : VirtualShiftToWorkload {
		- workload -> nextw
		- shift -> nexts
		.isSelected := true
		- requires_virtualShiftToWorkload -> prevvsw
	}
}

// Rule that selects an operation day for a patient. 
// That includes three edges to be adopted in the final model.
// I. + II.: between the patient and opTime and between patient and capacity -> Selects a day and OT for the patient
// III.: between opTime and Capacity to make sure the predefined surgeon of the patient is working in the correct OT on that day
rule selectOperationDay {
	root : Root {
		- patients -> p
		- surgeons -> s
		- ots -> ot
	}
	
	p : Patient {
		- firstWorkload -> w
		- surgeon -> s
	}
	
	w : Workload {
		- virtualCapacity -> vwc
		- virtualOpTime -> vwop
	}
	
	vwc : VirtualWorkloadToCapacity {
		- capacity -> c
		- requires_virtualOpTimeToCapacity -> vopc
		.isSelected := true
	}
	
	vwop : VirtualWorkloadToOpTime {
		- opTime -> op
		- requires_virtualOpTimeToCapacity -> vopc
		.isSelected := true
	}
	
	s : Surgeon {
		- opTimes -> op
	}
	
	op : OpTime {
		- virtualCapacity -> vopc
	}
	
	vopc : VirtualOpTimeToCapacity {
		- capacity -> c
		- enables_virtualWorkloadToOpTime -> vwop
		- enables_virtual_WorkloadToCapacity -> vwc
		.isSelected := true
	}
	
	ot : OT {
		- capacities -> c
	}
	
	c : Capacity
	 
	// Already expected in preprocessing. Not mandatory here
//	# op.day == c.day 
//	# p.earliestDay <= op.day 
//	# op.day <= p.dueDay
//	# p.surgeryDuration <= op.maxOpTime
//	# p.surgeryDuration <= c.maxCapacity
}

// Rule that selects an  VirtualShiftToRoster-Node to be adopted in the final model. 
rule selectShiftToRoster {
	root : Root {
		- nurses -> n
		- rooms -> r
	}
	
	n : Nurse {
		- rosters -> ro
	}
	
	ro : Roster {
		- virtualShift -> vsr
	}
	
	vsr : VirtualShiftToRoster {
		- shift -> s 
		.isSelected := true
	}
	
	s : Shift {
		- room -> r
	}
	
	r : Room
	
	// Already expected in preprocessing. Not mandatory here
	# ro.shiftNo == s.shiftNo
}

//
// Utility Patterns used in Constraints
//

// Pattern for all surgeries that  are assigned to a surgeon on a specific day
// TODO: maybe splitten?
pattern assignedSurgeries {
	root : Root {
		- ots -> ot
		- surgeons -> s
		- patients -> p
	}
	
	s : Surgeon {
		- opTimes -> op
	}
	
	p : Patient {
		- firstWorkload -> w
	}
	
	w : Workload {
		- virtualCapacity -> vwc
		- virtualOpTime -> vwop
	}
	
	vwc : VirtualWorkloadToCapacity {
		- capacity -> c
		- requires_virtualOpTimeToCapacity -> vopc
	}
	
	vwop : VirtualWorkloadToOpTime {
		- opTime -> op
		- requires_virtualOpTimeToCapacity -> vopc
	}
	
	op : OpTime {
		- virtualCapacity -> vopc
	}
	
	vopc : VirtualOpTimeToCapacity {
		- capacity -> c
	}
	
	ot : OT
	
	c : Capacity {
		- ot -> ot
	}
}

// Pattern to find all mandatory patients
pattern mandatoryPatients {
	r : Root {
		- patients -> p
	}
	
	p : Patient
	
	# p.mandatory == true
	# p.isOccupant == false
}

// Pattern to find all optional patients
pattern optionalPatients {
	r : Root {
		- patients -> p
	}
	
	p : Patient
	
	# p.mandatory == false
	# p.isOccupant == false
}

rule virtualNodesForOccupant {

	vsw : VirtualShiftToWorkload {
		.isSelected := true
	}
	# vsw.wasImported == true
}

// Pattern to Count the Patients over a specific room for a specific day -> enforce that the capacity of a room is not exceeded
// Needs to be checked for each morning shift (s.shiftNo % 3 == 0) -> remaining shifts of each day are automatically covered
pattern roomForShift{
	root : Root {
		- rooms -> r
	}
	
	r : Room {
		- shifts -> s
	}
	
	s : Shift
	
	# s.shiftNo % 3 == 0
}

// Pattern that finds all patients that are assigned to a room -> first and following workloads
pattern patientForRoom {
	root : Root {
		- patients -> p
		- rooms -> r
	}
	
	p : Patient {
//		- workloads -> w
	}
	
//	w : Workload {
//		- virtualShift -> vsw
//	}
//	
//	vsw : VirtualShiftToWorkload {
//		- shift -> s
//	}
	
	s : Shift {
//		- room -> r
	}
	
	r : Room 
	
	# s.shiftNo % 3 == 0 
}

pattern otForDay {
	root : Root {
		- ots -> ot
	}
	
	ot : OT {
		- capacities -> c
	}
	
	c : Capacity
}

pattern surgeonCapacity {
		root : Root {
		- surgeons -> s
	}
	
	s : Surgeon {
		- opTimes -> op
	}
	
	op : OpTime
}

pattern checkRequiredShiftToWorkload{
	root : Root {
		- virtualShiftToWorkload -> prevvsw
		- virtualShiftToWorkload -> nextvsw
	}
	
	prevvsw : VirtualShiftToWorkload {
		- enables_virtualShiftToWorkload -> nextvsw
	}
	
	nextvsw : VirtualShiftToWorkload
}

pattern checkRequiredWorkloadToCapacity{
	root : Root {
		- virtualShiftToWorkload -> vsw
		- virtualWorkloadToCapacity -> vwc
	}
	
	vsw : VirtualShiftToWorkload
	
	vwc : VirtualWorkloadToCapacity {
		- enables_virtualShiftToWorkload -> vsw
	}
}

// Finds pairs of patients that are assigned to the same room on the same morning shift
pattern patientTupel {
	root : Root {
		- patients -> p1
		- patients -> p2
	}
	
	p1 : Patient {
		- firstWorkload -> w1
	}
	
	w1 : Workload {
		- virtualShift -> vsw1
	}
	
	vsw1 : VirtualShiftToWorkload {
		- shift -> s
	}
	
	p2 : Patient {
		- firstWorkload -> w2
	}
	
	w2 : Workload {
		- virtualShift -> vsw2
	}
	
	vsw2 : VirtualShiftToWorkload {
		- shift -> s
	}
	
	s : Shift
	
	# s.shiftNo % 3 == 0
	# p1.gender != p2.gender
}

pattern patientShiftTupel {
	root : Root {
		- patients -> p 
	}
	
	p : Patient 
	
	s : Shift 
	
	# s.shiftNo % 3 == 0
}

//
// GIPSL 
//

//
// Mappings
//

// Decides in which room a patient is admitted -> Connects the first workload to a shift
mapping selectedShiftToFirstWorkload to selectShiftToFirstWorkload;

// Decides which following shifts are assigned to a patient (dependent on the room that was assigned to the first workload) 
// -> Connects all following workloads to a shift (The room is always the same and equal to the one selected in selectedShiftToFirstWorkload)
mapping selectedExtendingShiftToFirstWorkload to selectExtendingShiftToFirstWorkload;

// Decides on what day and in which OT a patient is operated on.
mapping selectedOperationDay to selectOperationDay;

//constraint with mandatoryPatients {
//	mappings.selectedOperationDay->filter(element.nodes.p == context.nodes.p)->sum(element.value) == 1
//}

// TODO: Fix Pattern 
//function maxUse with mandatoryPatients {
//	mappings.selectedOperationDay->filter(element.nodes.p == context.nodes.p)->sum(element.value)
//}

// Decides which nurses are assigned to a shift/room on a specific day.
mapping selectedShiftToRoster to selectShiftToRoster;


// Adds all imported Virtual Nodes of Occupants to the model
mapping selectedOccupantNodes to virtualNodesForOccupant;

// 
// Utility Mappings
//

// Mapping that holds the information how many patients are assigned to a room on a specific day
mapping countPatientsForRoom to roomForShift {
	var patientCount : EInt
};

// Mapping for all assigned patients. (occupants and new patients for each workload (first + following))
mapping assignedPatientsToRoom to patientForRoom;
 
// mapping that decides which ots are open on a specific day
mapping openOTs to otForDay;

//
// Hard Constraints
//

// H1: No gender mix: Patients of different genders may not share a room on any day. 
// patient.gender is a string variable and the preallocation is assumably not known. -> There can only be the same value for all patients

constraint with patientTupel {
	mappings.assignedPatientsToRoom->filter(
		[element.nodes.p == context.nodes.p1 | element.nodes.p == context.nodes.p2] &
		element.nodes.s == context.nodes.s
	)->sum(element.value) < 2
	// Alternative: should do the same
//	mappings.assignedPatientsToRoom->filter(
//		element.nodes.p == context.nodes.p1 &
//		element.nodes.s == context.nodes.s
//	)->sum(element.value) 
//	+
//	mappings.assignedPatientsToRoom->filter(
//		element.nodes.p == context.nodes.p2 &
//		element.nodes.s == context.nodes.s
//	)->sum(element.value)
//	< 2
}

// H2: Compatible rooms: Patients can only be assigned to one of their compatible rooms.
// -> Already enforced by GT-Rule "assignPatientToRoom" in preprocessing

// H3: Surgeon overtime: The maximum daily surgery time of a surgeon must not be exceeded. 

//constraint with assignedSurgeries {
//	mappings.selectedOperationDay->filter(
//		element.nodes.op.day == context.nodes.op.day &
//		element.nodes.s == context.nodes.s
//	)->sum(element.nodes.p.surgeryDuration * element.value)
//	<=
//	context.nodes.op.maxOpTime
//}

// H4: OT overtime: The duration of all surgeries allocated to an OT on a day must not exceed 
// its maximum capacity.

//constraint with assignedSurgeries {
//	mappings.selectedOperationDay->filter(
//		element.nodes.c.day == context.nodes.c.day &
//		element.nodes.ot == context.nodes.ot
//	)->sum(element.nodes.p.surgeryDuration * element.value)
//	<= 
//	context.nodes.c.maxCapacity
//}

// H5: Mandatory versus optional patients: All mandatory patients must be admitted within the 
// scheduling period, whereas optional patients may be postponed to future scheduling periods.

constraint with mandatoryPatients {
	mappings.selectedShiftToFirstWorkload->filter(element.nodes.p == context.nodes.p)->sum(element.value) == 1
//	&
//	mappings.selectedOperationDay->filter(element.nodes.p == context.nodes.p)->sum(element.value) == 1
}

//// TODO. temporary
//constraint with optionalPatients {
//	mappings.selectedShiftToFirstWorkload->filter(element.nodes.p == context.nodes.p)->sum(element.value) == 0
//}

// H6: Admission day: A patient can be admitted on any day from their release date to their
// due date.
// -> Already enforced by GT-Rule "fixOperationday"

// H7 Room capacity: The number of patients in each room in each day cannot exceed the 
// capacity of the room.

// The calculated amount of Patients assigned to each room on each morning shift of a day has to be 
// smaller or equal to the amount of available beds.
constraint with countPatientsForRoom {
	 context.variables.patientCount <= context.nodes.r.beds
}

//
// General Constraints
//

// C1: A patient is assigned to the same room during all shifts
// -> Already enforced by GT-Rule "extendPatientStay" in preprocessing

// C2: A patient is assigned to at most one room in each shift
constraint with Patient { // TODO: Überflüssig
	mappings.selectedShiftToFirstWorkload->filter(element.nodes.p == context)->sum(element.value) <=1
}

constraint with patientShiftTupel {
	mappings.assignedPatientsToRoom->filter(
		element.nodes.p == context.nodes.p &
		element.nodes.s.shiftNo == context.nodes.s.shiftNo
	)->sum(element.value) <= 1
}

// C3 + C4: Nurses are not assigned to empty rooms and each nonempty room in each shift is assigned to one nurse

//constraint with roomForShift {
//	mappings.countPatientsForRoom->filter(
//		element.nodes.r == context.nodes.r &
//		element.nodes.s.shiftNo == context.nodes.s.shiftNo
//		)->sum(element.variables.patientCount) == 0
//	=> 
//	mappings.selectedShiftToRoster->filter(
//		element.nodes.r == context.nodes.r &
//		element.nodes.s.shiftNo == context.nodes.s.shiftNo
//	)->sum(element.value) == 0
//	&
//	mappings.countPatientsForRoom->filter(
//		element.nodes.r == context.nodes.r &
//		element.nodes.s.shiftNo == context.nodes.s.shiftNo
//		)->sum(element.variables.patientCount) > 0
//	=> 
//	mappings.selectedShiftToRoster->filter(
//		element.nodes.r == context.nodes.r &
//		element.nodes.s.shiftNo == context.nodes.s.shiftNo
//	)->sum(element.value) == 1
//}

// C5: A patient is assigned to at most one operating time slot
// TODO Patient wahrscheinlich falsch -> Nicht occupant
//constraint with Patient {
//	mappings.selectedOperationDay->filter(element.nodes.p == context & !element.nodes.p.isOccupant)->sum(element.value) <= 1
//}

// C6: A surgeon without any operations on a specific day is not assigned an operating theater on that day
// -> Already given, because the rule selectOperationDay only assigns a surgeon to an OT if he has a scheduled
// operation with a patient on that day

//
// "Virtual" Constraints
//

// V1: All virtual nodes of occupants are selected
constraint with selectedOccupantNodes {
	context.value == 1
}

// V2: The virtual Node "VirtualWorkloadToShift" can only be added to the final model if
// the required Node "VirtualWorkloadToCapacity" is also selected (isSelected = true) 

//constraint with checkRequiredWorkloadToCapacity {
//	mappings.selectedShiftToFirstWorkload->filter(
//		element.nodes.vsw == context.nodes.vsw &
//		element.nodes.vwc == context.nodes.vwc
//	)->sum(element.value) == 1
//	=>
//	mappings.selectedOperationDay->filter(
//		element.nodes.vwc == context.nodes.vwc
//	)->sum(element.value) == 1
//}

//// V3: The stay of a patient can be extended by selecting a following Node "VirtualWorkloadToShift" 
//// that is connected to the previous links between the patients workloads to shifts.
//// The following node can only be selected if the previous is already set to true
//
//constraint with checkRequiredShiftToWorkload{
//	mappings.selectedExtendingShiftToFirstWorkload->filter(
//		element.nodes.prevvsw == context.nodes.prevvsw &
//		element.nodes.nextvsw == context.nodes.nextvsw 
//	)->sum(element.value) == 1
//	=>
//	mappings.selectedExtendingShiftToFirstWorkload->filter(
//		element.nodes.nextvsw == context.nodes.prevvsw 
//	)->sum(element.value) == 1
//	&
//	mappings.selectedExtendingShiftToFirstWorkload->filter(
//		element.nodes.prevvsw == context.nodes.prevvsw &
//		element.nodes.nextvsw == context.nodes.nextvsw 
//	)->sum(element.value) == 1
//	=>
//	mappings.selectedShiftToFirstWorkload->filter(
//		element.nodes.vsw == context.nodes.prevvsw 
//	)->sum(element.value) == 1
//}
//
// V4: TODO: Does the existing logic to set all three 3 nodes to true simultaneously work? 

// V5: Every virtual ShiftToWorkload Node of an Occupant has to be selected in the final model

//constraint with VirtualShiftToWorkload {
//	mappings.assignedPatientsToRoom->filter(
//		element.nodes.vsw == context & 
//		element.nodes.vsw.wasImported
//	)->sum(element.value) == 1
//	&
//	mappings.selectedExtendingShiftToFirstWorkload->filter(
//		element.nodes.nextvsw == context & 
//		element.nodes.nextvsw.wasImported
//	)->sum(element.value) == 1
//}

//
// Utility constraints
//

// Sets the mapping variable to 1 if a patient is assigned to a specific room for a specific day
// This occurs if one of the following criteria is met: They are mutually exclusive
// 1. The patient is assigned to a room (First workload) -> selectedShiftToFirstWorkload
// 2. The patients stay is extended. The room does not change -> selectedExtendingShiftToFirstWorkload
// 3. The patient is an occupant -> All his virtual Nodes are selected -> selectedOccupantNodes
// The amount of matches can be reduced by only checking for the morning shifts
constraint with assignedPatientsToRoom {
	[
	mappings.selectedShiftToFirstWorkload->filter(
		element.nodes.p == context.nodes.p &
		element.nodes.r == context.nodes.r &
		element.nodes.s == context.nodes.s
	)->sum(element.value) == 1
	|
	mappings.selectedExtendingShiftToFirstWorkload->filter(
		element.nodes.p == context.nodes.p &
		element.nodes.r == context.nodes.r &
		element.nodes.nexts == context.nodes.s
	)->sum(element.value) == 1
	|
	mappings.selectedOccupantNodes->filter(
		element.nodes.vsw.workload.patient == context.nodes.p & // TODO: Hat das irgendwelche negativen Auswirkungen?
		element.nodes.vsw.shift.room == context.nodes.r &
		element.nodes.vsw.shift == context.nodes.s
	)->sum(element.value) == 1 // sum(1) would give the same solution because all matches are selected
	]
	<=>
	context.value == 1
}

// Utility Constraint that counts how many patients are currently assigned to each room 
constraint with countPatientsForRoom {
	context.variables.patientCount 
	==
	mappings.assignedPatientsToRoom->filter(
		element.nodes.r == context.nodes.r &
		element.nodes.s.shiftNo == context.nodes.s.shiftNo
	)->sum(element.value)  
}

// sets the mapping to true if there is at least one surgery assigned to the ot on that day
//constraint with openOTs {
//	mappings.selectedOperationDay->filter(
//		element.nodes.ot == context.nodes.ot &
//		element.nodes.c.day == context.nodes.c.day
//	)->sum(element.value)
//	>= 
//	context.value // TODO: Geht auch >= 0?
//}

//
// Objectives
//

//// S1: The maximum difference of age groups in one room for each day should be minimized
//
//// TODO: Implement
//
//// S2: The nurse assigned to a room must have the minimum skill level required by patients in this room
//
//function calculateUnqualifiedNurses with assignedPatientsToRoom {
//	mappings.selectedShiftToRoster->filter(
//		element.nodes.r == context.nodes.r &
//		element.nodes.s.shiftNo == context.nodes.s.shiftNo &
//		element.nodes.n.skillLevel < context.nodes.w.minNurseSkill
//	)->sum(element.value) 
//}
//
//// S3: The number of nurses taking care of a specific patient must be minimized
//
//// TODO: Implement 
//
//// S4: The workload of a nurse should not exceed the assigned maximum workload
//
//// TODO: Implement 
//
//// S5: The number of OTs opened on each day should be minimized
//
//function calculateOPenOTs with openOTs {
//	context.value
//}
//
//// S6: The number of different OTs a surgeon is assigned to per working day should be minimized
//
//function calculateOtsPerSurgeon with surgeonCapacity {
//	mappings.selectedOperationDay->filter(
//		element.nodes.s == context.nodes.s &
//		element.nodes.op.day == context.nodes.op.day 
//	)->sum(element.value)
//}
//
//// S7: The number of days between a patient´s release date and their actual date of admission should be minimized
//
//function calculateWaitTime with selectedShiftToFirstWorkload {
//	((context.nodes.s.shiftNo / 3) - context.nodes.p.earliestDay) * context.value
//}
//
//// S8: The number of not admitted optional patients should be minimized
//function calculateNotAssignedOptionalPatients with optionalPatients {
//	1 - mappings.selectedShiftToFirstWorkload->filter(element.nodes.p == context.nodes.p)->sum(element.value)
//}

objective : max {
	0
//	+ functions.maxUse
//	+ functions.calculateWaitTime * types.Weight->sum(element.patientDelay)
//	+ functions.calculateUnqualifiedNurses * types.Weight->sum(element.roomNurseSkill)
//	+ functions.calculateOPenOTs * types.Weight->sum(element.openOperatingTheater)
//	+ functions.calculateNotAssignedOptionalPatients * types.Weight->sum(element.unscheduledOptional)
//	+ functions.calculateOtsPerSurgeon * types.Weight->sum(element.surgeonTransfer)
}