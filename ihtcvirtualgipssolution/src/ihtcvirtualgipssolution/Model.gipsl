package "ihtcvirtualgipssolution"
import "platform:/resource/ihtcvirtualmetamodel/model/Ihtcvirtualmetamodel.ecore"

config {  
	solver := GUROBI;
	timeLimit := true [value := 30.0];
	randomSeed := true [value := 0];
	presolve := true;
	debugOutput := true;
}

//
// GT
//

// (Utility) pattern to find already assigned surgeon OPs.
pattern surgeonOpIsAssigned {
	root : Root {
		- surgeons -> surgeon
		- ots -> o
	}
	
	surgeon : Surgeon {
		- opTimes -> op
	}
	
	op : OpTime {
		- derivedCapacities -> c
	}

	o : OT {
		- capacities -> c
	}
	
	c : Capacity
	
	# op.day == c.day
}
condition surgeonOpIsNotAssigned = forbid surgeonOpIsAssigned

// GT rule to assign a surgeon to an operation time.
rule assignSurgeonToOt {
	root : Root {
		- surgeons -> surgeon
		- ots -> o
	}
	
	surgeon : Surgeon {
		- opTimes -> op
	}
	
	op : OpTime {
		++ - derivedCapacities -> c
	}

	o : OT {
		- capacities -> c
	}
	
	c : Capacity
	
	# op.day == c.day
}
when surgeonOpIsNotAssigned

// Pattern that finds Patients which are assigned to a Room. 
// Used in assignPatientToRoom to count the Patients in a specific room
// Needs to Count over different links depending if the pre-existing links are changed to virtual nodes or not 
pattern findPatientsInRoom {
	root : Root {
		- patients -> patient
		- virtualShiftToWorkload -> virtualWorkload
	}
	
	patient : Patient {
		- firstWorkload -> workload
	}
	
	workload : Workload {
//		- derivedShift -> shift
		- virtualShift -> virtualWorkload
	}
	
	virtualWorkload : VirtualShiftToWorkload {
		- shift -> s
	}
	
	s : Shift {
		- room -> r
	}
	
	r : Room
	
	# virtualWorkload.wasImported == true 
}

// Pattern to find assigned first Shifts for Patients
pattern patientFirstShiftIsAssigned {
root : Root {
		- patients -> p
		- virtualShiftToWorkload -> vsw
		- rooms -> r
		- ots -> ot
	}
	
	p : Patient {
		- firstWorkload -> w
	}
	
	w : Workload {
		- derivedCapacity -> c
	}
	
	ot : OT {
		- capacities -> c
	}
	
	c : Capacity 
	
	vsw : VirtualShiftToWorkload {
		- workload -> w
		- shift -> s
	}
	
	s : Shift {
		- room -> r
	}
	
	r : Room
	
}
condition patientFirstShiftIsNotAssigned = forbid patientFirstShiftIsAssigned

// Pattern that finds incompatible rooms for patients
pattern uncompatibleRoomForPatient {
	root : Root {
		- patients -> p 
		- rooms -> r
	}
	
	p : Patient {
		- incompatibleRooms -> r
	}
	
	r : Room
}
condition compatibleRoomForPatient = forbid uncompatibleRoomForPatient

condition compatibleRoomAndNotAssigned = compatibleRoomForPatient && patientFirstShiftIsNotAssigned

// Pattern that creates a Virtual Node between Shift and Workload to assign a patient to a room 
rule assignPatientToRoom {
	root : Root {
		- patients -> p
		++ - virtualShiftToWorkload -> vsw
		- rooms -> r
		- ots -> ot
	}
	
	p : Patient {
		- firstWorkload -> w
	}
	
	w : Workload {
		- derivedCapacity -> c
	}
	
	ot : OT {
		- capacities -> c
	}
	
	c : Capacity 
	
	++ vsw : VirtualShiftToWorkload {
		++ - workload -> w
		++ - shift -> s
		.isSelected := false
		.wasImported := false
	}
	
	s : Shift {
		- room -> r
	}
	
	r : Room
	
	# s.shiftNo / 3 == c.day
	# s.shiftNo % 3 == 0
	# r.beds > count(findPatientsInRoom) // TODO vielleicht unnÃ¶tig
}
when compatibleRoomAndNotAssigned

pattern patientOperationDayIsAssigned {
	root : Root {
		- patients -> p
		- surgeons -> s
	}
	
	p : Patient {
		- firstWorkload -> w
		- surgeon -> s
	}
	
	w : Workload {
		- derivedOpTimes -> op
		- derivedCapacity -> c
	}
	
	s : Surgeon {
		- opTimes -> op
	}
	
	op : OpTime {
		- derivedCapacities -> c
	}
	
	c : Capacity
	
	# p.earliestDay <= op.day 
	# op.day <= p.dueDay
	# p.surgeryDuration <= op.maxOpTime
	# p.surgeryDuration <= c.maxCapacity
}
condition patientOperationDayIsnotAssigned = forbid patientOperationDayIsAssigned

// Rule that assigns a specific Operation Day to a Patient TODO: implement virtual
rule fixOperationday {
	root : Root {
		- patients -> p
		- surgeons -> s
	}
	
	p : Patient {
		- firstWorkload -> w
		- surgeon -> s
	}
	
	w : Workload {
		++ - derivedOpTimes -> op
		++ - derivedCapacity -> c
	}
	
	s : Surgeon {
		- opTimes -> op
	}
	
	op : OpTime {
		- derivedCapacities -> c

	}
	
	c : Capacity
	
	# p.earliestDay <= op.day 
	# op.day <= p.dueDay
	# p.surgeryDuration <= op.maxOpTime
	# p.surgeryDuration <= c.maxCapacity
}
when patientOperationDayIsnotAssigned

pattern patientStayCantBeExtended {
	root : Root {
		- patients -> p
		- virtualShiftToWorkload -> prevvsw
		- virtualShiftToWorkload -> nextvsw
		- rooms -> r
	}
	
	p : Patient {
		- workloads -> prevw // Funktioniert das oder ist dann firstworkload exklusive? 
	}
	
	prevw : Workload {
		- next -> nextw
	}
	
	nextw : Workload
	
	prevvsw : VirtualShiftToWorkload {
		- workload -> prevw
		- shift -> prevs
	}
	
	prevs : Shift {
		- next -> nexts
		- room -> r
	}
	
	nexts : Shift {
		- room -> r
	}
	
	r : Room
	
	nextvsw : VirtualShiftToWorkload {
		- workload -> nextw
		- shift -> nexts
	}
}
condition patientStayCanBeExtended = forbid patientStayCantBeExtended

rule extendPatientStay {
	// TODO
	root : Root {
		- patients -> p
		- virtualShiftToWorkload -> prevvsw
		++ - virtualShiftToWorkload -> nextvsw
		- rooms -> r
	}
	
	p : Patient {
		- workloads -> prevw // Funktioniert das? 
	}
	
	prevw : Workload {
		- next -> nextw
	}
	
	nextw : Workload
	
	prevvsw : VirtualShiftToWorkload {
		- workload -> prevw
		- shift -> prevs
	}
	
	prevs : Shift {
		- next -> nexts
		- room -> r
	}
	
	nexts : Shift {
		- room -> r
	}
	
	r : Room
	
	++ nextvsw : VirtualShiftToWorkload {
		++ - workload -> nextw
		++ - shift -> nexts
		.isSelected := false
		.wasImported := false
	}
	
	# nexts.shiftNo == prevs.shiftNo + 1 // Nicht notwendig wenn sortiert 
}
when patientStayCanBeExtended

pattern nurseToShiftIsAssigned {
	root : Root {
		- rooms -> r
		- nurses -> n
		- virtualShiftToRoster -> vsr
	}
	
	r : Room {
		- shifts -> s
	}
	
	s : Shift
	
	vsr : VirtualShiftToRoster {
		- roster -> ro
		- shift -> s
	}
	
	n : Nurse {
		- rosters -> ro
	}
	
	ro : Roster

	# ro.shiftNo == s.shiftNo
}
condition nurseToShiftIsNotAssigned = forbid nurseToShiftIsAssigned

rule assignNurseToRoom {
	root : Root {
		- rooms -> r
		- nurses -> n
		++ - virtualShiftToRoster -> vsr
	}
	
	r : Room {
		- shifts -> s
	}
	
	s : Shift
	
	++ vsr : VirtualShiftToRoster {
		++ - roster -> ro
		++ - shift -> s
		.isSelected := false
		.wasImported := false
	}
	
	n : Nurse {
		- rosters -> ro
	}
	
	ro : Roster 

	# ro.shiftNo == s.shiftNo
}
when nurseToShiftIsNotAssigned


//
// GIPSL 
//

mapping assignSurgeonMapping to assignSurgeonToOt;
