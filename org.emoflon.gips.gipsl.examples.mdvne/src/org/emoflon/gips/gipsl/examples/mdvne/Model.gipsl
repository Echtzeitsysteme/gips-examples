import "platform:/resource/network.model/model/Model.ecore" 
// you need a working iflye workspace to use this metamodel 
// check out: https://github.com/Echtzeitsysteme/iflye 
 
config {  
	solver := GUROBI [home:="fu", license:="bar"]; 
	launchConfig := true [main := "org.emoflon.gips.gipsl.examples.mdvne.ExampleMdVNE"];  
	timeLimit := true [value := 120.0];  
	randomSeed := true [value := 0];  
	presolve := true;  
	debugOutput := true;  
}  
 
// NACS 
condition serverNotMapped = forbid serverIsMapped 
pattern serverIsMapped { 
	host: SubstrateServer
	 
	virtualNode: VirtualServer { 
		-host -> host 
	} 
} 
 
condition switchNotMapped = forbid switchIsMapped 
pattern switchIsMapped { 
	host: SubstrateNode 
	 
	virtualSwitch: VirtualSwitch { 
		-host -> host 
	} 
} 
 
condition linkNotMapped = forbid linkIsMapped 
pattern linkIsMapped { 
	host: SubstrateHostLink 
	 
	virtualLink: VirtualLink { 
		-host -> host 
	} 
} 
 
// Actual rules 
rule serverMatchPositive() { 
	root: Root { 
		-networks -> substrateNetwork 
		-networks -> virtualNetwork 
	} 
	 
	substrateServer: SubstrateServer { 
		.residualCpu := substrateServer.residualCpu - virtualNode.cpu 
		.residualMemory := substrateServer.residualMemory - virtualNode.memory 
		.residualStorage := substrateServer.residualStorage - virtualNode.storage 
		++ -guestServers -> virtualNode 
	} 
	 
	virtualNode: VirtualServer { 
		++ -host -> substrateServer 
	} 
	 
	substrateNetwork: SubstrateNetwork { 
		-nodes -> substrateServer 
	} 
	 
	virtualNetwork: VirtualNetwork { 
		-nodes -> virtualNode 
	} 
	 
	# virtualNode.cpu <= substrateServer.residualCpu 
	# virtualNode.memory <= substrateServer.residualMemory 
	# virtualNode.storage <= substrateServer.residualStorage 
} 
when serverNotMapped 
 
rule switchNodeMatchPositive { 
	root: Root { 
		-networks -> substrateNetwork 
		-networks -> virtualNetwork 
	} 
	 
	substrateNode: SubstrateNode { 
		++ -guestSwitches -> virtualSwitch 
	} 
	 
	virtualSwitch : VirtualSwitch { 
		++ -host -> substrateNode 
	} 
	 
	substrateNetwork: SubstrateNetwork { 
		-nodes -> substrateNode 
	} 
	 
	virtualNetwork: VirtualNetwork { 
		-nodes -> virtualSwitch 
	} 
} 
when switchNotMapped 
 
rule linkPathMatchPositive { 
	root: Root { 
		-networks -> substrateNetwork 
		-networks -> virtualNetwork 
	} 
	 
	substratePath: SubstratePath { 
		++ -guestLinks -> virtualLink 
		.residualBandwidth := substratePath.residualBandwidth - virtualLink.bandwidth 
		 
		// Update all substrate links 
		forEach links->l { 
			iterator::l.residualBandwidth := iterator::l.residualBandwidth - virtualLink.bandwidth 
		} 
	} 
	 
	virtualLink: VirtualLink { 
		++ -host -> substratePath 
	} 
	 
	substrateNetwork: SubstrateNetwork { 
		-paths -> substratePath 
	} 
	 
	virtualNetwork: VirtualNetwork { 
		-links -> virtualLink 
	} 
	 
	# virtualLink.bandwidth <= substratePath.residualBandwidth 
	 
	// Explicitly exclude substrate paths with a residual bandwidth equals to 0 
	# substratePath.residualBandwidth > 0 
} 
when linkNotMapped 
 
rule linkServerMatchPositive { 
	root: Root { 
		-networks -> substrateNetwork 
		-networks -> virtualNetwork 
	} 
	 
	substrateServer: SubstrateServer { 
		++ -guestLinks -> virtualLink 
	} 
	 
	virtualLink: VirtualLink { 
		++ -host -> substrateServer 
	} 
	 
	substrateNetwork: SubstrateNetwork { 
		-nodes -> substrateServer 
	} 
	 
	virtualNetwork: VirtualNetwork { 
		-links -> virtualLink 
	} 
} 
when linkNotMapped 
 
// TODO: Future work: Network embedding 
//rule networkRule { 
//	root: Root { 
//		-networks -> substrateNetwork 
//		-networks -> virtualNetwork 
//	} 
//	 
//	substrateNetwork: SubstrateNetwork { 
//		++ -guests -> virtualNetwork 
//	} 
//	 
//	virtualNetwork: VirtualNetwork { 
//		++ -host -> substrateNetwork 
//	} 
//} 
 
// 
// GIPSL starts here! 
// 
 
// TODO: Future work: Network embedding 
//mapping net2net with networkRule; 
////constraint -> class::VirtualNetwork { 
////	self.nodes->filter(n | n.nodes().)->count() == 0 
////} 
//constraint -> match::networkRule { 
////	mappings.srv2srv->filter(s | s.nodes().virtualServer == self.nodes().virtualNetwork.nodes) 
//	self.nodes().virtualNetwork.nodes->filter(n | n == ) 
//} 
 
// Server 2 Server 
mapping srv2srv with serverMatchPositive; 
constraint -> class::VirtualServer { 
	mappings.srv2srv->filter(m | m.nodes().virtualNode == self)->count() == 1 
} 
 
objective srvObj -> mapping::srv2srv { 
    self.nodes().substrateServer.residualCpu / self.nodes().substrateServer.cpu +  
    self.nodes().substrateServer.residualMemory / self.nodes().substrateServer.memory +  
    self.nodes().substrateServer.residualStorage / self.nodes().substrateServer.storage 
} 
 
constraint -> class::SubstrateServer { 
	mappings.srv2srv->filter(match | match.nodes().substrateServer == self)->sum(match | match.nodes().virtualNode.cpu) <= self.residualCpu & 
    mappings.srv2srv->filter(match | match.nodes().substrateServer == self)->sum(match | match.nodes().virtualNode.memory) <= self.residualMemory & 
    mappings.srv2srv->filter(match | match.nodes().substrateServer == self)->sum(match | match.nodes().virtualNode.storage) <= self.residualStorage 
} 
 
// Switch 2 Node 
mapping sw2node with switchNodeMatchPositive; 
constraint -> class::VirtualSwitch { 
	mappings.sw2node->filter(match | match.nodes().virtualSwitch == self)->count() == 1 
} 
 
// Link 2 Path 
mapping l2p with linkPathMatchPositive; 
constraint -> pattern::linkPathMatchPositive { 
	(mappings.srv2srv->filter(mpp | mpp.nodes().virtualNode == self.nodes().virtualLink.source & mpp.nodes().substrateServer == self.nodes().substratePath.source)->count() + 
		mappings.sw2node->filter(mpp | mpp.nodes().virtualSwitch == self.nodes().virtualLink.source & mpp.nodes().substrateNode == self.nodes().substratePath.source)->count()) + 
	(mappings.srv2srv->filter(mpp | mpp.nodes().virtualNode == self.nodes().virtualLink.target & mpp.nodes().substrateServer == self.nodes().substratePath.target)->count() + 
		mappings.sw2node->filter(mpp | mpp.nodes().virtualSwitch == self.nodes().virtualLink.target & mpp.nodes().substrateNode == self.nodes().substratePath.target)->count()) 
	>= 2 * mappings.l2p->filter(mpp | mpp.nodes().substratePath == self.nodes().substratePath & mpp.nodes().virtualLink == self.nodes().virtualLink)->count() 
} 
objective lpObj -> mapping::l2p { 
	self.nodes().virtualLink.bandwidth * self.nodes().substratePath.hops 
} 
 
constraint -> class::SubstratePath { 
	mappings.l2p->filter(match | match.nodes().substratePath == self)->sum(match | match.nodes().virtualLink.bandwidth) <= self.residualBandwidth 
} 
 
// Link 2 Server 
mapping l2s with linkServerMatchPositive; 
constraint -> pattern::linkServerMatchPositive { 
	(mappings.srv2srv->filter(mpp | mpp.nodes().virtualNode == self.nodes().virtualLink.source & mpp.nodes().substrateServer == self.nodes().substrateServer)->count() + 
		mappings.sw2node->filter(mpp | mpp.nodes().virtualSwitch == self.nodes().virtualLink.source & mpp.nodes().substrateNode == self.nodes().substrateServer)->count()) + 
	(mappings.srv2srv->filter(mpp | mpp.nodes().virtualNode == self.nodes().virtualLink.target & mpp.nodes().substrateServer == self.nodes().substrateServer)->count() + 
		mappings.sw2node->filter(mpp | mpp.nodes().virtualSwitch == self.nodes().virtualLink.target & mpp.nodes().substrateNode == self.nodes().substrateServer)->count()) 
	>= 2 * mappings.l2s->filter(mpp | mpp.nodes().substrateServer == self.nodes().substrateServer & mpp.nodes().virtualLink == self.nodes().virtualLink)->count() 
} 
 
constraint -> class::VirtualLink { 
	mappings.l2p->filter(m | m.nodes().virtualLink == self)->count() + 
	mappings.l2s->filter(m | m.nodes().virtualLink == self)->count() == 1 
} 
 
// Global objective 
global objective : min { 
	srvObj + lpObj 
} 
