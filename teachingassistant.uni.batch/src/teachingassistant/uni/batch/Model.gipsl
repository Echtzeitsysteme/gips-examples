package "teachingassistant.uni.batch"
import "platform:/resource/teachingassistant.uni.metamodel/model/Metamodel.ecore"

config {
	solver := GUROBI;
	timeLimit := true [value := 120.0];
	randomSeed := true [value := 0];
	presolve := auto;
	debugOutput := true;
//	lpOutput := true [path := "problem.lp"];
}

//
// GT
//

// Find session occurrence
pattern findSessionOccurrence {
	session : TeachingSession {
		- occurrences -> occurrence
	}
	
	occurrence : SessionOccurrence
}

// Construct a condition for a session that a specific TA
// is available (i.e., they have not blocked this session)
pattern findTaUnavailableSession {
	ta : TeachingAssistant {
		- unavailable -> blocked
	}
	
	session : TeachingSession {
		- entries -> entry
	}
	
	entry : TimeTableEntry {
		- timeTableWeeks -> week
	}
	
	blocked : TimeTableEntry {
		- timeTableWeeks -> week
	}
	
	week : Week
	
	# entry.day == blocked.day
	# entry.startMinutes < blocked.endMinutes
	# entry.endMinutes > blocked.startMinutes
}
condition taAvailableInSession = forbid findTaUnavailableSession

// Rule to assign a TA to a specific session occurrence.
// This rule respects the condition that the TA must not have
// blocked the respective time table entry of the session occurrence.
rule assignTa {
	ta : TeachingAssistant
	
	module : Module {
		- sessions -> session
		- approvals -> approval
	}
	
	session : TeachingSession {
		- occurrences -> occurrence
		- entries -> entry
	}
	
	occurrence : SessionOccurrence {
		++ - tas -> ta
	}
	
	w : Week
	
	entry : TimeTableEntry {
		- timeTableWeeks -> w
	}
	
	approval : EmploymentApproval {
		- ta -> ta
	}
	
	# occurrence.timeTableWeek == w.id
	# approval.ratingNumeric > 0
}
when taAvailableInSession

// Find every possible combination of TAs
// and time table entries
pattern findTaEntryCombination {
	ta : TeachingAssistant
	entry : TimeTableEntry
}

// For a specific TA, find all conflicting time table
// entries in the model.
// This pattern does respect partly overlapping time
// table entries.
pattern findConflictingEntriesWithTa {
	week : Week
	
	entryA : TimeTableEntry {
		- timeTableWeeks -> week
	}
	entryB : TimeTableEntry {
		- timeTableWeeks -> week
	}
	
	ta : TeachingAssistant
	
	# entryA.startMinutes < entryB.endMinutes
	# entryA.endMinutes > entryB.startMinutes
	
	// The day must match
	# entryA.day == entryB.day
}

// Find all possible combinations of TAs and weeks
pattern findTaWeekCombination {
	w : Week
	ta : TeachingAssistant
}

// Find a TA with a green employment approval status
// for a specific module.
pattern findGreenTa {
	ta : TeachingAssistant
	
	mod : Module {
		- approvals -> approval
	}
	
	approval : EmploymentApproval {
		- ta -> ta
	}
	# approval.ratingNumeric == 2
}

// Find a TA with an amber employment approval status
// for a specific module.
pattern findAmberTa {
	ta : TeachingAssistant
	
	mod : Module {
		- approvals -> approval
	}
	
	approval : EmploymentApproval {
		- ta -> ta
	}
	# approval.ratingNumeric == 1
}

pattern findInterCampusTimeTableEntriesConflict {
	ta : TeachingAssistant
	
	week : Week
	
	entryA : TimeTableEntry {
		- timeTableWeeks -> week
		- room -> roomA
	}
	roomA : Room {
		- campus -> campusA
	}
	campusA : Campus
	
	entryB : TimeTableEntry {
		- timeTableWeeks -> week
		- room -> roomB
	}
	roomB : Room {
		- campus -> campusB
	}
	campusB : Campus
	
	// Match day
	# entryA.day == entryB.day
	
	// Time frame between A.end and B.start is < 60 minutes
	# entryB.startMinutes - entryA.endMinutes < 60
	
	// No time conflict, A finished before B
	# entryA.endMinutes <= entryB.startMinutes
}

pattern findOccurrenceContinuity {
	ta : TeachingAssistant
	
	module : Module {
		- sessions -> session
		- approvals -> approval
	}
	
	session : TeachingSession {
		- occurrences -> occurrenceA
		- occurrences -> occurrenceB
	}
	
	occurrenceA : SessionOccurrence
	occurrenceB : SessionOccurrence
	
	approval : EmploymentApproval {
		- ta -> ta
	}
	
	# occurrenceA.timeTableWeek + 1 == occurrenceB.timeTableWeek
	# approval.ratingNumeric > 0
}

//
// GIPSL
//

// If a mapping instance has a value of `1`, the respective TA must
// be mapped to the respective session occurrence.
mapping taToOccurrence to assignTa;

// If a mapping instance has a value of `1`, the respective TA will be used
// in the session occurrence of week `w` and in week `w + 1`
mapping continuity to findOccurrenceContinuity;

// Every session occurrence must have exactly `numTAsPerSession` TAs assigned.
constraint with findSessionOccurrence {
	mappings.taToOccurrence->join((occurrence, occurrence))->sum(element.value)
	==
	context.nodes.session.numTasPerSession
}

// TAs must not have conflicting assignments.
// GIPSL formulation: For any pair of conflicting session occurrences (in the
// context of one TA), a maximum of one of these conflicting session can be chosen.
constraint with findConflictingEntriesWithTa {
	mappings.taToOccurrence->join((ta, ta), (entry, entryA))->sum(element.value)
	+ mappings.taToOccurrence->join((ta, ta), (entry, entryB))->sum(element.value)
	<= 1
}

// TAs must have at least 1h = 3600s to switch campus in between assignments.
// GIPSL formulation: For any pair of time table entries that could be assigned
// to a single TA, which require inter-campus travel, and which time window for
// a switch is less than 1h = 3600s, a maximum of one of these sessions can be
// chosen.
constraint with findInterCampusTimeTableEntriesConflict {
	mappings.taToOccurrence->join((ta, ta), (entry, entryA))->sum(element.value)
	+ mappings.taToOccurrence->join((ta, ta), (entry, entryB))->sum(element.value)
	<= 1
}

// Ensure TAs total max hours
// GIPSL interpretation: the sum of all assigned working hours per TA
// must not exceed their total hour limit
constraint with TeachingAssistant {
	mappings.taToOccurrence->join(ta)->sum(element.value * element.nodes.session.hoursPaidPerOccurrence)
	<= context.maxHoursTotal
}

// Ensure TAs max hours per week
// GIPSL interpretation: the sum of all assigned working hours per TA
// in a specific week must not exceed their weekly hour limit
constraint with findTaWeekCombination {
	mappings.taToOccurrence->join((ta, ta), (w, w))->sum(element.value * element.nodes.session.hoursPaidPerOccurrence)
	<= context.nodes.ta.maxHoursPerWeek
}

// Represents the number of assigned session occurrences to a specific
// TA for a specific session (and the TA needs to have the green
// employment rating for the respective module).
function greenTas with findGreenTa {
	mappings.taToOccurrence->join((ta, ta), (module, mod))->sum(element.value)
}

// Represents the number of assigned session occurrences to a specific
// TA for a specific session (and the TA needs to have the amber
// employment rating for the respective module).
function amberTas with findAmberTa {
	mappings.taToOccurrence->join((ta, ta), (module, mod))->sum(element.value)
}

// If (and only if) the same TA is used in a session occurrence in
// week `w1` and in a session occurrence in week `w2`, set the respective
// binary variable of the corresponding continuity mapping to `1`.
constraint with continuity {
//	[context.value == 1] //
//
//	<=>
//	
//	[mappings.taToOccurrence->filter( //
//		element.nodes.ta == context.nodes.ta //
//		& element.nodes.occurrence == context.nodes.occurrenceA //
//	)->sum(element.value)
//	+
//	mappings.taToOccurrence->filter( //
//		element.nodes.ta == context.nodes.ta //
//		& element.nodes.occurrence == context.nodes.occurrenceB //
//	)->sum(element.value)
//	== 2]

	// Faster replacement
	2 * context.value
	<=
	mappings.taToOccurrence->join((ta, ta), (occurrence, occurrenceA))->sum(element.value)
	+
	mappings.taToOccurrence->join((ta, ta), (occurrence, occurrenceB))->sum(element.value)
	
	&
	
	context.value
	>=
	mappings.taToOccurrence->join((ta, ta), (occurrence, occurrenceA))->sum(element.value)
	+
	mappings.taToOccurrence->join((ta, ta), (occurrence, occurrenceB))->sum(element.value)
	- 1
}

// Represents the number of selected continuity variables.
function continuity with continuity {
	context.value
}

// Global objective
objective : max {
	0
	// We want to use a higher weight for green TAs compared to the
	// amber TAs
	+ 2 * functions.greenTas
	+ 1 * functions.amberTas
	// Continuity weighted by a constant factor beta.
	+ 1 * functions.continuity
}
