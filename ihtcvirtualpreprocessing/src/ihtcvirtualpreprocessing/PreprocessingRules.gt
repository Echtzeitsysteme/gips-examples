import "platform:/resource/ihtcvirtualmetamodel/model/Ihtcvirtualmetamodel.ecore"

//
// GT rules for the pre-processing of a (virtual) model
//

//
// Pre-processing for all virtual elements between `Roster` and `Shift`
//

// Finds an existing virtual roster shift object for a specific
// roster and a specific shift.
pattern findVirtualRoster {
	roster: Roster

	shift: Shift

	v: VirtualShiftToRoster {
		-roster -> roster
		-shift -> shift
	}
}
condition noVirtualRoster = forbid findVirtualRoster

// Create a new virtual shift to roster object for a specific
// shift and a specific roster. There must not be an existing
// virtual shift to roster object connecting those two.
rule assignNurseToRoom {
	root: Root {
		-nurses -> nurse
		-rooms -> room
	}

	nurse: Nurse {
		-rosters -> roster
	}

	roster: Roster

	room: Room {
		-shifts -> shift
	}

	shift: Shift {
		++ - virtualRoster -> vnew
	}

	++ vnew: VirtualShiftToRoster {
		++ -roster -> roster
		++ -shift -> shift
		.isSelected := false
	}
	
	# roster.shiftNo == shift.shiftNo
}
when noVirtualRoster

//
// Pre-processing for all first virtual elements between `Shift` and `Workload`
//

// Pattern to find assigned first Shifts for Patients
pattern patientFirstShiftIsAssigned {
	w : Workload 
	
	vsw : VirtualShiftToWorkload {
		- workload -> w
		- shift -> s
	}
	
	s : Shift 
}
condition patientFirstShiftIsNotAssigned = forbid patientFirstShiftIsAssigned

// Pattern that finds incompatible rooms for patients
pattern incompatibleRoomForPatient {
	p : Patient {
		- incompatibleRooms -> r
	}
	
	r : Room
}
condition compatibleRoomForPatient = forbid incompatibleRoomForPatient

condition compatibleRoomAndNotAssigned = compatibleRoomForPatient && patientFirstShiftIsNotAssigned

// Pattern that creates a Virtual Node between Shift and Workload to assign a patient to a room 
rule assignPatientToRoom {
	root : Root {
		- patients -> p
		- rooms -> r
	}
	
	p : Patient {
		- firstWorkload -> w
	}
	
	w : Workload
	
	ot : OT {
		- capacities -> c
	}
	
	c : Capacity
	
	vexist : VirtualWorkloadToCapacity {
		- capacity -> c
		- workload -> w
		++ - enables_virtualShiftToWorkload -> vnew
		// Explicitly set the opposite edge
	}
	
	++ vnew : VirtualShiftToWorkload {
		++ - workload -> w
		++ - shift -> s
		.isSelected := false
		.wasImported := false
		++ - requires_virtualWorkloadToCapacity -> vexist
	}
	
	s : Shift {
		- room -> r
		++ - virtualWorkload -> vnew
	}
	
	r : Room
	
	# s.shiftNo % 3 == 0
	# p.isOccupant == false
	
	// Optimization: patient must be ready by the current day.
	// I.e., it is never an option to set the admission day of a patient to
	// a day before the patient's first possible admission day so we can
	// already remove these matches using the PM.
	# s.shiftNo / 3 >= p.earliestDay
	
	// Optimization: patient's due date must not be violated.
	// I.e., it is never an option to set the admission day of a patient to
	// a day after the patient's due day so we can already remove these
	// matches using the PM.
	# s.shiftNo / 3 <= p.dueDay
	
	// Day of the first assigned shift must match the day of the OT's
	// capacity object.
	# s.shiftNo / 3 == c.day
}
when compatibleRoomAndNotAssigned

//
// Pre-processing for succeeding first virtual elements between `Shift` and `Workload`
//

pattern nextVirtualShiftToWorkloadExists {
	nextw : Workload
	
	nexts : Shift
	
	nextvsw : VirtualShiftToWorkload {
		- workload -> nextw
		- shift -> nexts
	}
}
condition nextVirtualShiftToWorkloadDoesNotExist = forbid nextVirtualShiftToWorkloadExists

rule extendPatientStay {
	root : Root {
		- patients -> p
		- rooms -> r
	}
	
	p : Patient {
		- workloads -> prevw
	}
	
	prevw : Workload {
		- next -> nextw
	}
	
	nextw : Workload
	
	prevvsw : VirtualShiftToWorkload {
		- workload -> prevw
		- shift -> prevs
		++ - enables_virtualShiftToWorkload -> vnew
		// Explicitly set the opposite edge
	}
	
	prevs : Shift {
		- next -> nexts
		- room -> r
	}
	
	nexts : Shift {
		- room -> r
		++ - virtualWorkload -> vnew
	}
	
	r : Room
	
	++ vnew : VirtualShiftToWorkload {
		++ - workload -> nextw
		++ - shift -> nexts
		.isSelected := false
		.wasImported := false
		++ - requires_virtualShiftToWorkload -> prevvsw
	}

	# p.isOccupant == false
}
when nextVirtualShiftToWorkloadDoesNotExist

//
// Pre-processing for existing (non-virtual) edges between `Shift` and `Workload`
//

rule preprocessOccupantsWorkload {
	root : Root {
		- patients -> p
		- rooms -> r
	}
	
	p : Patient {
		- workloads -> w
	}
	
	w : Workload {
		-- - derivedShift -> s
	}
	
	s : Shift {
		- room -> r
		// Explicitly delete both edges
		// (Maybe deleting one is sufficient)
		-- - derivedWorkloads -> w
		++ - virtualWorkload -> vnew
	}
	
	r : Room
	
	++ vnew : VirtualShiftToWorkload {
		++ - workload -> w
		++ - shift -> s
		.isSelected := false
		.wasImported := true
	}
	
	# p.isOccupant == true
}

//
// Pre-processing for surgeon and operating theaters
//

pattern findVirtualOpTimeToCapacity {
	op : OpTime
	
	c: Capacity
	
	v: VirtualOpTimeToCapacity {
		- capacity -> c
		- opTime -> op
	}
}
condition noOpTimeToCapacity = forbid findVirtualOpTimeToCapacity

rule assignSurgeonToOt {
	root : Root {
		- surgeons -> s
		- ots -> o
	}
	
	s : Surgeon {
		- opTimes -> op
	}
	
	op : OpTime
	
	o : OT {
		- capacities -> c
	}
	
	c : Capacity {
		++ - virtualOpTime -> vnew
	}
	
	++ vnew : VirtualOpTimeToCapacity {
		++ - opTime -> op
		++ - capacity -> c
		.isSelected := false
	}
	
	# op.day == c.day
	# c.maxCapacity > 0
	# op.maxOpTime > 0
}
when noOpTimeToCapacity

//
// Pre-processing for workloads, OP time, and capacity
//

pattern findVirtualWorkloadToOpTime {
	w: Workload
	op: OpTime
	
	v : VirtualWorkloadToOpTime {
		- opTime -> op
		- workload -> w
	}
}
condition noVirtualEdgeWorkloadToOpTime = forbid findVirtualWorkloadToOpTime

pattern findVirtualWorkloadToCapacity {
	w: Workload
	c: Capacity
	
	v : VirtualWorkloadToCapacity {
		- capacity -> c
		- workload -> w
	}
}
condition noVirtualEdgeWorkloadToCapacity = forbid findVirtualWorkloadToCapacity

//condition noWorkloadAssignment = forbid findVirtualWorkloadToOpTime && forbid findVirtualWorkloadToCapacity

//pattern integratedWorkloadToOp {
//	w: Workload
//	op: OpTime
//	
//	va : VirtualWorkloadToOpTime {
//		- opTime -> op
//		- workload -> w
//	}
//	
//	c: Capacity
//	
//	vb : VirtualWorkloadToCapacity {
//		- capacity -> c
//		- workload -> w
//	}
//}
//
//condition noWorkloadAssignment = forbid integratedWorkloadToOp

//rule fixOperationDay {
//	root : Root {
//		- patients -> p
//		- surgeons -> s
//	}
//	
//	p : Patient {
//		- firstWorkload -> w
//		- surgeon -> s
//	}
//	
//	w : Workload
//	
//	s : Surgeon {
//		- opTimes -> op
//	}
//	
//	op : OpTime {
//		++ - virtualWorkload -> vnew
//	}
//	
//	c : Capacity {
//		++ - virtualWorkload -> vnew2
//	}
//	
//	vexist : VirtualOpTimeToCapacity {
//		- capacity -> c
//		- opTime -> op
//		// Explicitly set the opposite edge
//		++ - enables_virtualWorkloadToOpTime -> vnew
//		++ - enables_virtual_WorkloadToCapacity -> vnew2
//	}
//	
//	++ vnew : VirtualWorkloadToOpTime {
//		++ - opTime -> op
//		++ - workload -> w
//		.isSelected := false
//		++ - requires_virtualOpTimeToCapacity -> vexist
//	}
//	
//	++ vnew2 : VirtualWorkloadToCapacity {
//		++ - capacity -> c
//		++ - workload -> w
//		.isSelected := false
//		++ - requires_virtualOpTimeToCapacity -> vexist
//	}
//	
//	# p.earliestDay <= op.day
//	# op.day <= p.dueDay
//	# p.surgeryDuration <= op.maxOpTime
//	# p.surgeryDuration <= c.maxCapacity
////	# p.isOccupant == false
//	// Already checked via the edge between `p` and `s`
//}
//when noWorkloadAssignment

rule fixOperationDayOpTime {
	p : Patient {
		- firstWorkload -> w
		- surgeon -> s
	}
	
	w : Workload
	
	s : Surgeon {
		- opTimes -> op
	}
	
	op : OpTime {
		++ - virtualWorkload -> vnew
	}
	
	vexist : VirtualOpTimeToCapacity {
		- opTime -> op
		// Explicitly set the opposite edge
		++ - enables_virtualWorkloadToOpTime -> vnew
	}
	
	++ vnew : VirtualWorkloadToOpTime {
		++ - opTime -> op
		++ - workload -> w
		.isSelected := false
		++ - requires_virtualOpTimeToCapacity -> vexist
	}
	
	# p.earliestDay <= op.day
	# op.day <= p.dueDay
	# p.surgeryDuration <= op.maxOpTime
//	# p.isOccupant == false
	// Already checked via the edge between `p` and `s`
}
when noVirtualEdgeWorkloadToOpTime

rule fixOperationDayCapacity {
	p : Patient {
		- firstWorkload -> w
	}
	
	w : Workload
	
	c : Capacity {
		++ - virtualWorkload -> vnew2
	}
	
	vexist : VirtualOpTimeToCapacity {
		- capacity -> c
		// Explicitly set the opposite edge
		++ - enables_virtual_WorkloadToCapacity -> vnew2
	}
	
	++ vnew2 : VirtualWorkloadToCapacity {
		++ - capacity -> c
		++ - workload -> w
		.isSelected := false
		++ - requires_virtualOpTimeToCapacity -> vexist
	}
	
	# p.surgeryDuration <= c.maxCapacity
	# p.isOccupant == false
}
when noVirtualEdgeWorkloadToCapacity
