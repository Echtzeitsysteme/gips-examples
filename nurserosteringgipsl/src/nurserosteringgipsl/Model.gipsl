package "nurserosteringgipsl"
import "platform:/resource/nurserosteringmodel/model/Nurserosteringmodel.ecore"

config {  
	solver := GUROBI;
	timeLimit := true [value := 120.0];
	randomSeed := true [value := 0];
	presolve := true;
	debugOutput := true;
	tolerance := true [value := 0.00001];
	lpOutput := true [path := "gurobi.lp"];
}

//
// This GIPSL specification aims at solving the "Nurse Rostering Competition 1" (NRC1) with GIPS.
//
// The current state is incomplete, i.e., not all (soft and hard) constraints are taken into account.
//

pattern findNurseCompleteWeekendsWithSaturday {
	root : Root {
		- employees -> nurse
	}
	
	nurse : Employee {
		- contract -> c
	}
	
	c : Contract
	
	day : Day {
		
	}
	
	# c.completeWeekends == true
	
	// Day must be a Saturday
	# day.dayOfWeekNumeric == 6 
}

mapping nurseCompleteWeekendSaturday to findNurseCompleteWeekendsWithSaturday;

pattern findEmployeeDayCombinationWeekend {
	root : Root {
		- days -> day
		- employees -> employee
	}
	employee : Employee
	day : Day
	
	# day.dayOfWeekNumeric >= 6 
	# day.dayOfWeekNumeric <= 7 
}

mapping employeeDayCombinationWeekend to findEmployeeDayCombinationWeekend;


pattern findNurseNoNightShiftBeforeFreeWeekend{
	root : Root {
		- employees -> nurse
	}
	
	nurse : Employee {
		- contract -> c
	}
	
	c : Contract
	
	day : Day {
		
	}
	
	shift : Shift {
		- day -> day
	}
	
	
	# c.noNightShiftBeforeFreeWeekend == true
	
	// Day must be a Friday
	# day.dayOfWeekNumeric == 5
}

mapping nurseNoNightShiftBeforeFreeWeekend to findNurseNoNightShiftBeforeFreeWeekend;

pattern findNurseWeekendIdenticalShift {
	root : Root {
		- employees -> nurse
		- shifts -> shift
	}
	
	nurse : Employee {
		- contract -> c
	}
	
	c : Contract
	
	day : Day {
		
	}
	
	shift : Shift {
		- day -> day
	}
	
	
	# c.identicalShiftTypesDuringTheWeekend == true
	
	// Day must be a Saturday
	# day.dayOfWeekNumeric == 6
}

mapping nurseWeekendIdenticalShift to findNurseWeekendIdenticalShift;

// This rule assigns an employee to a shift on a specific
// day.
rule assignEmployeeToShift {
	root : Root {
		- employees -> employee
		- days -> day
	}
	employee : Employee
	day : Day {
		- requirements -> cr
	}
	cr : CoverRequirement {
		- shift -> shift
	}
	shift : Shift {
		++ - assignedEmployees -> employee
	}
	
	// check if employee.skills.contains(shift.skills)
	// is missing because of IBeX-GT language limitations
}

// Finds all possible combinations of employee and days.
pattern findEmployeeDayCombination {
	root : Root {
		- days -> day
		- employees -> employee
	}
	employee : Employee
	day : Day
}





// Finds all possible combinations of a required skill,
// a shift, and an employee having this skill.
pattern findShiftSkillEmployeeCombination {
	shift : Shift {
		- skills -> skill
	}
	skill : Skill
	employee : Employee {
		- skills -> skill
	}
}

// Finds all possible combinations of shifts and required
// skills.
pattern findNeededShiftSkill {
	shift : Shift {
		- skills -> skill
	}
	skill : Skill
}

pattern findEmployee {
	emp : Employee
}

mapping findEmp to findEmployee;


pattern findCoverRequirement{
	cr : CoverRequirement
}

mapping findCr to findCoverRequirement;

pattern findViolatedDayOffRequest {
	dayOffRequest : DayOffRequest{
		
	}
	
	employee : Employee{
		
	}
	
	day : Day {
		
	}
	
	# employee.employeeId == dayOffRequest.employeeId
	# day.number == dayOffRequest.dateNumber
}

mapping violatedDaysOff to findViolatedDayOffRequest;

constraint with violatedDaysOff{
	mappings.e2s->filter( //
		element.nodes.employee == context.nodes.employee //
		& element.nodes.day.number == context.nodes.dayOffRequest.dateNumber //

	)->sum(element.value) >= 1
	
	<=>
	
	context.value == 1
}


pattern findViolatedShiftOff {
	shiftOffRequest : ShiftOffRequest{
		
	}
	employee : Employee{
		
	}
	
	shiftType : ShiftType{
		
	}
	
	day : Day{
		
	}
	
	shift : Shift{
		- day -> day
		- type -> shiftType
	}
	
	# employee.employeeId == shiftOffRequest.employeeID
	# shiftType.shiftTypeId == shiftOffRequest.shiftTypeID
	# day.number == shiftOffRequest.dateNumber
}

mapping violatedShiftOff to findViolatedShiftOff;



constraint with violatedShiftOff {
	mappings.e2s->filter( 
		element.nodes.employee == context.nodes.employee 
		& element.nodes.shift == context.nodes.shift 
	)->sum(element.value) >= 1
	
	<=>
	
	context.value == 1
}


// Mapping for every employee and shift.
// If a mapping `m` was selected by the (M)ILP solver,
// the respective employee `e` will be assigned to shift `s`.
mapping e2s to assignEmployeeToShift;

// Mapping for every shift, skill, and employee combination.
// If a mapping `m` was selected by the (M)ILP solver,
// the respective employee `e` works on shift `s` and has
// the required skill `skill`.
mapping skillShiftAssignment to findShiftSkillEmployeeCombination;

// "all demanded shifts must be assigned to a nurse;"
//GIPS interpretation:
//every cover requirement has a number of preferred employees.
// This constraint ensures that the shift connected to this cover requirement gets
// as many employees mapped as this cover requirement's "preferred".
constraint with CoverRequirement {
	mappings.e2s->filter(element.nodes.shift == context.shift)->sum(element.value) == context.preferred // vorher == context.preferred
}

//every cover requirement has a number of preferred employees.
// This constraint ensures that the shift connected to this cover requirement gets
// as many employees mapped as this cover requirement's "preferred".
//constraint with findCr {
//	mappings.e2s->filter(element.nodes.shift == context.nodes.cr.shift)->sum(element.value) == context.nodes.cr.preferred // >=1 instead ?
//	
//	<=>
//	
//	context.value == 1
//}

// "a nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day."
// GIPS interpretation: every combination of employee and day
// must contain at most one selected mapping.
constraint with findEmployeeDayCombination {
	mappings.e2s->filter(
		element.nodes.employee == context.nodes.employee
		& element.nodes.shift.day == context.nodes.day
	)->sum(element.value)
	<= 1
}

// Helper constraint: if at least one mapping of employee `e` to shift `s` is selected,
// set the respective `skillShiftAssignment` mapping to 1.
constraint with findShiftSkillEmployeeCombination {
	mappings.e2s->filter(
		element.nodes.shift == context.nodes.shift
		& element.nodes.employee == context.nodes.employee
	)->sum(element.value) >= 1
	<=>
	mappings.skillShiftAssignment->filter(
		element.nodes.shift == context.nodes.shift
		& element.nodes.skill == context.nodes.skill
		& element.nodes.employee == context.nodes.employee
	)->sum(element.value) == 1
	// ^notice: the Boolean equivalence operator `<=>` is very expensive
	// in terms of required compute power.
}

// TODO: This constraint is currently disabled. Otherwise, the solver
// does not find a valid solution for `sprint01.xml` -> should be investigated.
////// Minimum/maximum number of shifts that can be assigned to an employee
constraint with findEmp {
		
	mappings.e2s->filter(element.nodes.employee == context.nodes.emp)->sum(element.value) < context.nodes.emp.contract.minimumNoOfAssignments
	|
	mappings.e2s->filter(element.nodes.employee == context.nodes.emp)->sum(element.value) > context.nodes.emp.contract.maximumNoOfAssignments
		
	<=>
	
	context.value == 1

}

//maxWorkingWeekendsInFourWeeks (soft constraint)
//is automatically limited to four weeks
//because the scheduling period is four weeks in every xml file
constraint with employeeDayCombinationWeekend {
	mappings.e2s->filter(
		element.nodes.employee == context.nodes.employee
		& element.nodes.shift.day == context.nodes.day
	)->sum(element.value)
	> context.nodes.employee.contract.maximumNoOfWorkWeekendsInFourWeeks
	
	<=>
	
	context.value == 1
}

// Required skills of a shift must be matched.
// GIPSL interpretation: every skill required by a shift must be present
// at least once.
constraint with findNeededShiftSkill {
	mappings.skillShiftAssignment->filter(
		element.nodes.shift == context.nodes.shift
		& element.nodes.skill == context.nodes.skill
	)->sum(element.value) >= 1
}

//// should probably be a soft constraint
constraint with nurseCompleteWeekendSaturday {
	// find all Saturdays
![
	[
		mappings.e2s->filter( //
			element.nodes.employee == context.nodes.nurse //
			& element.nodes.day.number == context.nodes.day.number
		)->sum(element.value)
		== 1
	]
	
	<=>

	[
		mappings.e2s->filter( //
			element.nodes.employee == context.nodes.nurse //
			& element.nodes.day.number == context.nodes.day.number + 1 //
		)->sum(element.value)
		== 1
	]
]
	
	<=>
	
	context.value == 1
}

//// should probably be a soft constraint
constraint with nurseWeekendIdenticalShift {
	
![	
	[
		mappings.e2s->filter( //
			// employee must match
			element.nodes.employee == context.nodes.nurse //
			// number of the day must match
			& element.nodes.day.number == context.nodes.day.number //
			// shift type must match
			& element.nodes.shift.type == context.nodes.shift.type //
		)->sum(element.value)
		== 1
	]
	
	<=>
	
	[
		mappings.e2s->filter( //
			element.nodes.employee == context.nodes.nurse //
			// number of the day must be one day later -> Sunday
			& element.nodes.day.number == context.nodes.day.number + 1 //
			& element.nodes.shift.type == context.nodes.shift.type //
		)->sum(element.value)
		== 1
	]
	
]

  <=>

    context.value == 1
    
}



constraint with nurseNoNightShiftBeforeFreeWeekend {
![	
	[
			mappings.e2s->filter( //
			element.nodes.employee == context.nodes.nurse //
			
			& element.nodes.day.number == context.nodes.day.number + 1 //
			& element.nodes.shift.type == context.nodes.shift.type//
		)->sum(element.value)
		+
		mappings.e2s->filter( //
			element.nodes.employee == context.nodes.nurse //
			
			& element.nodes.day.number == context.nodes.day.number + 2 //
			& element.nodes.shift.type == context.nodes.shift.type//
		)->sum(element.value)
		== 0
	]
	
	=> //no nightshift 
	
	[
		mappings.e2s->filter( //
			// employee must match
			element.nodes.employee == context.nodes.nurse //
			// number of the day must match
			& element.nodes.day.number == context.nodes.day.number //
			// shift type must match
			& element.nodes.shift.type == context.nodes.shift.type
			& element.nodes.shift.type.shiftTypeId == 0
		)->sum(element.value)
		== 0
	]
	
]
	
	<=>
	
	context.value == 1
}

function violatedDaysFunc with violatedDaysOff {
	context.value
}

function violatedShiftsFunc with violatedShiftOff{
	context.value
}

objective : min {
	functions.violatedDaysFunc + functions.violatedShiftsFunc
}



// =>
// <=>
