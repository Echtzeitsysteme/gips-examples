package "nurserosteringgipsl"
import "platform:/resource/nurserosteringmodel/model/Nurserosteringmodel.ecore"

config {  
	solver := GUROBI [home:="fu", license:="bar"];
	timeLimit := true [value := 120.0];
	randomSeed := true [value := 0];
	presolve := true;
	debugOutput := true;
	tolerance := true [value := 0.00001];
	lpOutput := true [path := "gurobi.lp"];
}

rule assignEmployeeToShift {
	root : Root {
		- employees -> employee
		- days -> day
	}
	
	employee : Employee
	day : Day {
		- requirements -> cr
	}
	cr : CoverRequirement {
		- shift -> shift
	}
	shift : Shift {
		++ - assignedEmployees -> employee
	}
	
	// check if employee.skills.contains(shift.skills)
	// is missing because of IBeX-GT language limitations
}

pattern findEmployeeDayCombination {
	root : Root {
		- days -> day
		- employees -> employee
	}
	employee : Employee
	day : Day
}

//pattern findShiftSkillEmployeeCombination {
//	shift : Shift {
//		- skills -> skill
//	}
//	
//	skill : Skill
//	
//	employee : Employee {
//		- skills -> skill
//	}
//}
//
//pattern findNeededShiftSkill {
//	shift : Shift {
//		- skills -> skill
//	}
//	
//	skill : Skill
//}

mapping e2s with assignEmployeeToShift;

//// Mapping for every shift, skill, and employee combination.
//// If a mapping `m` was selected by the ILP solver,
//// the respective employee `e` works on shift `s` and has
//// the required skill `skill`.
//mapping skillShiftAssignment with findShiftSkillEmployeeCombination;

// "all demanded shifts must be assigned to a nurse;"
// GIPS interpretation: every cover requirement has a number of preferred employees.
// This constraint ensures that the shift connected to this cover requirement gets
// as many employees mapped as this cover requirement's "preferred".
constraint -> class::CoverRequirement {
	mappings.e2s->filter(m | m.nodes().shift == self.shift)->count() == self.preferred
}

// "a nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day."
constraint -> pattern::findEmployeeDayCombination {
	mappings.e2s->filter(m | m.nodes().employee == self.nodes().employee & m.nodes().shift.day == self.nodes().day
	)->count()
	<= 1
}

// Helper constraint: if at least one mapping of employee `e` to shift `s` is selected,
// set the respective `skillShiftAssignment` mapping to 1.
//constraint -> pattern::findShiftSkillEmployeeCombination {
////	mappings.e2s->filter(m | m.nodes().shift == self.nodes().shift)
//	mappings.skillShiftAssignment->filter(m | m.nodes().shift == self.nodes().shift & m.nodes().skill == self.nodes().skill)->count() == 1
//	<=>
//	mappings.e2s->filter(m | m.nodes().shift == self.nodes().shift & m.nodes().employee == self.nodes().employee)->count() >= 1
//}

//// Minimum/maximum number of shifts that can be assigned to an employee
//constraint -> class::Employee {
//	mappings.e2s->filter(m | m.nodes().employee == self)->count() >= self.contract.minimumNoOfAssignments
//	&
//	mappings.e2s->filter(m | m.nodes().employee == self)->count() <= self.contract.maximumNoOfAssignments
//}

// Required skills of a shift must be matched.
// GIPSL interpretation: every skill required by a shift must be present
// at least once.
//constraint -> pattern::findNeededShiftSkill {
//	mappings.skillShiftAssignment->filter(m | m.nodes().shift == self.nodes().shift & m.nodes().skill == self.nodes().skill)->count() >= 1
//}
