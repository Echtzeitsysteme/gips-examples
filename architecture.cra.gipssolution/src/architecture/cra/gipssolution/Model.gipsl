package "architecture.cra.gipssolution"
import "platform:/resource/ArchitectureCRA/model/architectureCRA.ecore"

config {  
	solver := GUROBI [home:="fu", license:="bar"];
	timeLimit := true [value := 3600.0];
	randomSeed := true [value := 0];
	presolve := true;
	debugOutput := true;
	tolerance := true [value := 0.00001];
	lpOutput := true [path := "gurobi.lp"];
}

//
// Utilities for embedding a single attribute or a single method
//

pattern findSingleAttribute {
	a : Attribute
}

//rule embedACTuple {
rule embedACTuple {
	a : Attribute
	c : Clazz {
		++ - encapsulates -> a
	}
}

pattern findSingleMethod {
	m : Method
}

rule embedMCTuple {
	m : Method
	c : Clazz {
		++ - encapsulates -> m
	}
}

mapping embedMethod with embedMCTuple;

// every method must be embedded
constraint -> pattern::findSingleMethod {
	mappings.embedMethod->filter(m | m.nodes().m == self.nodes().m)->count() == 1
}

mapping embedAttribute with embedACTuple;

// every attribute must be embedded
constraint -> pattern::findSingleAttribute {
	mappings.embedAttribute->filter(m | m.nodes().a == self.nodes().a)->count() == 1
}

//
// Violation of type A:
// a method `m` has a dependency to an attribute `a` which should be mapped to a different class than the method `m`
//
//
//pattern findViolationA {
//	c1 : Class
//	c2 : Class
//	a1 : Attribute
//	m1 : Method {
//		- dataDependency -> a1
//	}
//}
//
//mapping violationA with findViolationA;

//constraint -> pattern::findViolationA {
//	// workaround for == in <=> constraints
//	mappings.violationA->filter(
//		m | m.nodes().a1 == self.nodes().a1
//		& m.nodes().m1 == self.nodes().m1
//		& m.nodes().c1 == self.nodes().c1
//		& m.nodes().c2 == self.nodes().c2
//	)->count() >= 1
//	<=>
//	[
//		mappings.embedAttribute->filter(m | m.nodes().a == self.nodes().a1 & m.nodes().c == self.nodes().c1)->count() >= 1
//		&
//		mappings.embedMethod->filter(m | m.nodes().m == self.nodes().m1 & m.nodes().c == self.nodes().c2)->count() >= 1
//	]
//	// TODO: reformulate this with a more efficient constraint
//}
//
//objective objViolationA -> mapping::violationA {
//	1
//}

//
// Violation of type B:
// two methods with no common attribute dependency should not be placed in the same class
//

//pattern findViolationB {
//	c1 : Clazz
//	m1 : Method
//	m2 : Method
//}
//when twoMethodsWithNoSharingAttribute
//
//condition twoMethodsWithNoSharingAttribute = forbid findAMMCQuadruple
//pattern findAMMCQuadruple {
//	c1 : Clazz
//	a1 : Attribute
//	m1 : Method {
//		- dependencies -> a1
//	}
//	m2 : Method {
//		- dependencies -> a1
//	}
//}
//
//mapping violationB with findViolationB;
//
//constraint -> pattern::findViolationB {
//	// workaround for == in <=> constraints
//	mappings.violationB->filter(
//		m | m.nodes().m1 == self.nodes().m1
//		& m.nodes().m2 == self.nodes().m2
//	)->count() >= 1
//	<=>
//	[
//		mappings.embedMethod->filter(m | m.nodes().m == self.nodes().m1 & m.nodes().c == self.nodes().c1)->count() >= 1
//		&
//		mappings.embedMethod->filter(m | m.nodes().m == self.nodes().m2 & m.nodes().c == self.nodes().c1)->count() >= 1
//	]
//	// TODO: reformulate this with a more efficient constraint
//}
//
//objective objViolationB -> mapping::violationB {
//	1
//}

//
// Violation of type C:
// a method `a` has a dependency to a method `b` which should be mapped to a different class than the method `a`
//

//pattern findViolationC {
//	c1 : Class
//	c2 : Class
//	m1 : Method {
//		- functionalDependency -> m2
//	}
//	m2 : Method
//}
//
//mapping violationC with findViolationC;
//
////constraint -> pattern::findViolationC {
//	// workaround for == in <=> constraints
//	mappings.violationC->filter(
//		m | m.nodes().m1 == self.nodes().m1
//		& m.nodes().m2 == self.nodes().m2
//		& m.nodes().c1 == self.nodes().c1
//		& m.nodes().c2 == self.nodes().c2
//	)->count() >= 1
//	<=>
//	[
//		mappings.embedMethod->filter(m | m.nodes().m == self.nodes().m1 & m.nodes().c == self.nodes().c1)->count() >= 1
//		&
//		mappings.embedMethod->filter(m | m.nodes().m == self.nodes().m2 & m.nodes().c == self.nodes().c2)->count() >= 1
//	]
//	// TODO: reformulate this with a more efficient constraint
//}
//
//objective objViolationC -> mapping::violationC {
//	1
//}

//
// Violation of type D1:
// a method 'a' has no dependency to a method 'b' which both should be mapped to the same class
//

//pattern findViolationD1 {
//	c : Class
//	m1 : Method {
//		- functionalDependency -> m2
//	}
//	m2 : Method
//}
//
//mapping violationD1 with findViolationD1;
//
//constraint -> pattern::findViolationD1 {
//	// workaround for == in <=> constraints
//	mappings.violationD1->filter(
//		m | m.nodes().m1 == self.nodes().m1
//		& m.nodes().m2 == self.nodes().m2
//		& m.nodes().c == self.nodes().c
//	)->count() >= 1
//	<=>
//	[
//		mappings.embedMethod->filter(m | m.nodes().m == self.nodes().m1 & m.nodes().c == self.nodes().c)->count() >= 1
//		&
//		mappings.embedMethod->filter(m | m.nodes().m == self.nodes().m2 & m.nodes().c == self.nodes().c)->count() >= 1
//	]
//	// TODO: reformulate this with a more efficient constraint
//}
//
//objective objViolationD1 -> mapping::violationD1 {
//	1
//}

//
// Violation of type D2:
// a method 'a' has no dependency to an attribute 'b' which both should be mapped to the same class
//

//pattern findViolationD2 {
//	c : Class
//	m : Method {
//		- dataDependency -> a
//	}
//	a : Attribute
//}
//
//mapping violationD2 with findViolationD2;
//
//constraint -> pattern::findViolationD2 {
//	// workaround for == in <=> constraints
//	mappings.violationD2->filter(
//		m | m.nodes().m == self.nodes().m
//		& m.nodes().a == self.nodes().a
//		& m.nodes().c == self.nodes().c
//	)->count() >= 1
//	<=>
//	[
//		mappings.embedMethod->filter(m | m.nodes().m == self.nodes().m & m.nodes().c == self.nodes().c)->count() >= 1
//		&
//		mappings.embedAttribute->filter(m | m.nodes().a == self.nodes().a & m.nodes().c == self.nodes().c)->count() >= 1
//	]
//	// TODO: reformulate this with a more efficient constraint
//}
//
//objective objViolationD2 -> mapping::violationD2 {
//	1
//}

// minimize the number of violations
//global objective : min {
//	objViolationA
////	+ objViolationB
////	+ objViolationC
////	+ objViolationD1
////	+ objViolationD2
//}
