package "architecture.cra.gipssolution"
import "platform:/resource/ArchitectureCRA/model/architectureCRA.ecore"

config {  
	solver := GUROBI [home:="fu", license:="bar"];
	timeLimit := true [value := 3600.0];
	randomSeed := true [value := 0];
	presolve := true;
	debugOutput := true;
	tolerance := true [value := 0.00001];
	lpOutput := true [path := "gurobi.lp"];
}

//
// Utilities for embedding a single attribute or a single method
//

pattern findSingleAttribute {
	a : Attribute
}

rule embedACTuple {
	a : Attribute
	c : Clazz {
		++ - encapsulates -> a
	}
}

pattern findSingleMethod {
	m : Method
}

rule embedMCTuple {
	m : Method
	c : Clazz {
		++ - encapsulates -> m
	}
}

mapping embedMethod with embedMCTuple;

// every method must be embedded
constraint -> pattern::findSingleMethod {
	mappings.embedMethod->filter(m | m.nodes().m == self.nodes().m)->count() == 1
}

mapping embedAttribute with embedACTuple;

// every attribute must be embedded
constraint -> pattern::findSingleAttribute {
	mappings.embedAttribute->filter(m | m.nodes().a == self.nodes().a)->count() == 1
}

//
// Violation of type A:
// a method `m` has a dependency to an attribute `a` which should be mapped to a different class than the method `m`
//

pattern findViolationA {
	c1 : Clazz
	c2 : Clazz
	a1 : Attribute
	m1 : Method {
		- dataDependency -> a1
	}
}

mapping violationA with findViolationA;

constraint -> pattern::findViolationA {
	mappings.violationA->filter(
		m | m.nodes().a1 == self.nodes().a1
		& m.nodes().m1 == self.nodes().m1
		& m.nodes().c1 == self.nodes().c1
		& m.nodes().c2 == self.nodes().c2
	)->count() == 1
	<=>
	[
		mappings.embedAttribute->filter(m | m.nodes().a == self.nodes().a1 & m.nodes().c == self.nodes().c1)->count() == 1
		&
		mappings.embedMethod->filter(m | m.nodes().m == self.nodes().m1 & m.nodes().c == self.nodes().c2)->count() == 1
	]
}

objective objViolationA -> mapping::violationA {
	1
}

//
// Violation of type C:
// a method `a` has a dependency to a method `b` which should be mapped to a different class than the method `a`
//

pattern findViolationC {
	c1 : Clazz
	c2 : Clazz
	m1 : Method {
		- functionalDependency -> m2
	}
	m2 : Method
}

mapping violationC with findViolationC;

constraint -> pattern::findViolationC {
	mappings.violationC->filter(
		m | m.nodes().m1 == self.nodes().m1
		& m.nodes().m2 == self.nodes().m2
		& m.nodes().c1 == self.nodes().c1
		& m.nodes().c2 == self.nodes().c2
	)->count() == 1
	<=>
	[
		mappings.embedMethod->filter(m | m.nodes().m == self.nodes().m1 & m.nodes().c == self.nodes().c1)->count() == 1
		&
		mappings.embedMethod->filter(m | m.nodes().m == self.nodes().m2 & m.nodes().c == self.nodes().c2)->count() == 1
	]
}

objective objViolationC -> mapping::violationC {
	1
}

pattern findPositiveC {
	c : Clazz
	m1 : Method {
		- functionalDependency -> m2
	}
	m2 : Method
}

mapping positiveC with findPositiveC;

constraint -> pattern::findPositiveC {
	mappings.positiveC->filter(
		m | m.nodes().m1 == self.nodes().m1
		& m.nodes().m2 == self.nodes().m2
		& m.nodes().c == self.nodes().c
	)->count() == 1
	<=>
	[
		mappings.embedMethod->filter(m | m.nodes().m == self.nodes().m1 & m.nodes().c == self.nodes().c)->count() == 1
		&
		mappings.embedMethod->filter(m | m.nodes().m == self.nodes().m2 & m.nodes().c == self.nodes().c)->count() == 1
	]
}

objective objPositiveC -> mapping::positiveC {
	1
}

//
// Violation of type D1:
// a method 'a' has no dependency to a method 'b' which both should be mapped to the same class
//

condition mmNoDep = forbid findHelperD1
pattern findHelperD1 {
	m1: Method {
		- functionalDependency -> m2
	}
	m2: Method
}

pattern findViolationD1 {
	c : Clazz
	m1 : Method
	m2 : Method
}
when mmNoDep

mapping violationD1 with findViolationD1;

constraint -> pattern::findViolationD1 {
	mappings.violationD1->filter(
		m | m.nodes().m1 == self.nodes().m1
		& m.nodes().m2 == self.nodes().m2
		& m.nodes().c == self.nodes().c
	)->count() == 1
	<=>
	[
		mappings.embedMethod->filter(m | m.nodes().m == self.nodes().m1 & m.nodes().c == self.nodes().c)->count() == 1
		&
		mappings.embedMethod->filter(m | m.nodes().m == self.nodes().m2 & m.nodes().c == self.nodes().c)->count() == 1
	]
}

objective objViolationD1 -> mapping::violationD1 {
	1
}

//
// Violation of type D2:
// a method 'a' has no dependency to an attribute 'b' which both should be mapped to the same class
//

condition maNoDep = forbid findHelperD2
pattern findHelperD2 {
	m: Method {
		- dataDependency -> a
	}
	a: Attribute
}

pattern findViolationD2 {
	c : Clazz
	m : Method
	a : Attribute
}
when maNoDep

mapping violationD2 with findViolationD2;

constraint -> pattern::findViolationD2 {
	mappings.violationD2->filter(
		m | m.nodes().m == self.nodes().m
		& m.nodes().a == self.nodes().a
		& m.nodes().c == self.nodes().c
	)->count() == 1
	<=>
	[
		mappings.embedMethod->filter(m | m.nodes().m == self.nodes().m & m.nodes().c == self.nodes().c)->count() == 1
		&
		mappings.embedAttribute->filter(m | m.nodes().a == self.nodes().a & m.nodes().c == self.nodes().c)->count() == 1
	]
}

objective objViolationD2 -> mapping::violationD2 {
	1
}

// minimize the number of violations
global objective : min {
	0.5 * objViolationA
	+ 0.5 * objViolationC
	+ objViolationD1
	+ objViolationD2
	
//	- objPositiveC

//	objViolationC
}
