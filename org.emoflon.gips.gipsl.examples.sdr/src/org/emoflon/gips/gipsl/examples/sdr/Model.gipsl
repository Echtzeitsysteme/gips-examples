package "org.emoflon.gips.gipsl.examples.sdr"
import "platform:/resource/org.emoflon.gips.gipsl.examples.sdrmodel/model/Sdrmodel.ecore"

config {  
	solver := GUROBI [home:="fu", license:="bar"];
	launchConfig := true [main := "TODO"];
	timeLimit := true [value := 30.0];
	randomSeed := true [value := 0];
	presolve := true;
	debugOutput := true;
}

rule block2thread {
	root: Root {
		-cpus -> cpu
		-jobs -> job
	}
	
	cpu: CPU {
		-cores -> core
		++ -guests -> job
	}
	
	// Also pins the job to a CPU
	job: Job {
		-blocks -> block
		++ -hosts -> cpu
	}
	
	core: Core {
		-threads -> thread
	}
	
	thread: Thread {
		++ -guests -> block
	}
	
	block: Block {
		++ -host -> thread
	}
	
//	# thread.processResource > 0
//	# thread.processResource >= block.processDemand
}

rule flow2intercom {
	root: Root {
		-cpus -> cpu
		-jobs -> job
	}
	
	cpu: CPU {
		-intercoms -> intercom
	}
	
	job: Job {
		-flows -> flow
	}
	
	flow: Flow {
		++ -host -> intercom
	}
	
	intercom: Interthreadcom {
		++ -flowGuests -> flow
	}
}

rule flow2thread {
	root: Root {
		-cpus -> cpu
		-jobs -> job
	}
	
	cpu: CPU {
		-cores -> core
	}
	
	job: Job {
		-flows -> flow
	}
	
	core: Core {
		-threads -> thread
	}
	
	flow: Flow {
		++ -host -> thread
	}
	
	thread: Thread {
		++ -flowGuests -> flow
	}
}

pattern thread {
	thread: Thread
}

//
// GIPSL starts here!
//

mapping b2t with block2thread;
mapping f2i with flow2intercom;
mapping f2t with flow2thread;

mapping usedThread with thread;

//constraint -> pattern::thread {
////	mappings.b2t->filter(m | m.nodes().thread == self.nodes().thread)->count() > 0
////	& mappings.usedThread->filter(m | m.nodes().thread == self.nodes().thread)->count() > 0
//
//	mappings.b2t->filter(m | m.nodes().thread == self.nodes().thread)->count() >= 0.1
//	=> [mappings.usedThread->filter(m | m.nodes().thread == self.nodes().thread)->count() <= 1
//		& mappings.usedThread->filter(m | m.nodes().thread == self.nodes().thread)->count() >= 1
//	]
//
////	&
////	
////	mappings.b2t->filter(m | m.nodes().thread == self.nodes().thread)->count()
////	>= mappings.usedThread->filter(m | m.nodes().thread == self.nodes().thread)->count()
//	
//	
//	// 1 => 1 = 1
//	// 1 => 0 = 0
//	// 0 => 1 = 1
//	// 0 => 0 = 1
//	
//	// 1 => 1 = 1
//	// 1 => 0 = 0
//	// 0 => 1 = 0
//	// 0 => 0 = 1
//}
//
//constraint -> pattern::thread {
//	mappings.b2t->filter(m | m.nodes().thread == self.nodes().thread)->count()
//	>= mappings.usedThread->filter(m | m.nodes().thread == self.nodes().thread)->count()
//}

constraint -> class::Thread {
	mappings.b2t->filter(m | m.nodes().thread == self)->count() >= 1
	=> mappings.usedThread->filter(m | m.nodes().thread == self)->count() >= 1
}
constraint -> class::Thread {
	mappings.b2t->filter(m | m.nodes().thread == self)->count()
	>= mappings.usedThread->filter(m | m.nodes().thread == self)->count()
}

//constraint -> pattern::thread {
////	mappings.b2t->filter(m | m.nodes().thread == self.nodes().thread)->count() > 0
////	& mappings.usedThread->filter(m | m.nodes().thread == self.nodes().thread)->count() > 0
//
////	mappings.b2t->filter(m | m.nodes().thread == self.nodes().thread)->count() >= 0.1
////	=> [mappings.usedThread->filter(m | m.nodes().thread == self.nodes().thread)->count() <= 1
////		& mappings.usedThread->filter(m | m.nodes().thread == self.nodes().thread)->count() >= 1
////	]
////	
////	&
////	mappings.b2t->filter(m | m.nodes().thread == self.nodes().thread)->count()
////	>= mappings.usedThread->filter(m | m.nodes().thread == self.nodes().thread)->count()
//
//	[mappings.b2t->filter(m | m.nodes().thread == self.nodes().thread)->count() >= 0.1]
//	==
//	[mappings.usedThread->filter(m | m.nodes().thread == self.nodes().thread)->count() == 1]
//	
//	
//	// 1 => 1 = 1
//	// 1 => 0 = 0
//	// 0 => 1 = 1
//	// 0 => 0 = 1
//	
//	// 1 => 1 = 1
//	// 1 => 0 = 0
//	// 0 => 1 = 0
//	// 0 => 0 = 1
//}
//
//constraint -> class::Block {
//	[1 == self.cycles]
//	==
//	[2 == self.cycles]
//}

// Every block must be mapped to a (=1) thread
constraint -> class::Block {
	mappings.b2t->filter(m | m.nodes().block == self)->count() == 1
}

//constraint -> class::Job {
//	mappings.b2t->filter(m | m.nodes().job == self)->count() == 1
//}

//// Thread process resources must not be over subscribed
//constraint -> class::Thread {
//	mappings.b2t->filter(m | m.nodes().thread == self)->sum(m | m.nodes().block.processDemand) <= self.processResource
//}

// Every flow must be mapped to an intercom or a thread
constraint -> class::Flow {
	mappings.f2i->filter(m | m.nodes().flow == self)->count() +
	mappings.f2t->filter(m | m.nodes().flow == self)->count()
	== 1
}

// Start and target of a flow must be embedded on its host counter parts (1, intercom)
constraint -> pattern::flow2intercom {
	mappings.b2t->filter(m | m.nodes().block == self.nodes().flow.source & m.nodes().thread == self.nodes().intercom.source)->count() +
	mappings.b2t->filter(m | m.nodes().block == self.nodes().flow.target & m.nodes().thread == self.nodes().intercom.target)->count()
	>= 2 * mappings.f2i->filter(m | m.nodes().intercom == self.nodes().intercom & m.nodes().flow == self.nodes().flow)->count()
}

// Start and target of a flow must be embedded on its host counter parts (2, thread)
constraint -> pattern::flow2thread {
	mappings.b2t->filter(m | m.nodes().block == self.nodes().flow.source & m.nodes().thread == self.nodes().thread)->count() +
	mappings.b2t->filter(m | m.nodes().block == self.nodes().flow.target & m.nodes().thread == self.nodes().thread)->count()
	>= 2 * mappings.f2t->filter(m | m.nodes().thread == self.nodes().thread & m.nodes().flow == self.nodes().flow)->count()
}

// Sanity check: All blocks must demand <= all threads resources
//constraint -> class::Job {
//	self.blocks->sum(b | b.processDemand) <= classes.Thread->sum(t | t.processResource)
//}

// Objective = inter-thread communication
objective intercomcost -> class::Interthreadcom {
//	mappings.f2i->filter(m | m.nodes().intercom == self)->sum(m | m.nodes().flow.rate)
	mappings.f2i->filter(m | m.nodes().intercom.source.core == m.nodes().intercom.target.core & m.nodes().intercom == self)->sum(m | m.nodes().flow.rate) * 2 +
	mappings.f2i->filter(m | m.nodes().intercom.source.core != m.nodes().intercom.target.core & m.nodes().intercom == self)->sum(m | m.nodes().flow.rate) * 6
}

objective f2tcost -> mapping::f2t {
	1
}

// Each thread wants to minimize its used cycles
//objective b2tcost -> class::Thread {
//	mappings.b2t->filter(m | m.nodes().thread == self)->sum(m | m.nodes().block.cycles)
//}

//objective b2tcost -> class::Thread {
//	mappings.b2t->filter(m | m.nodes().thread == self)->count()
//}

objective glob -> class::Root {
//	classes.Block->count() - mappings.usedThread->count()
	-(mappings.usedThread->count())
}

//objective to -> class::Thread {
//	mappings.b2t->filter(m | m.nodes().thread == self)->count()
//}

//constraint -> 

//objective b2tcostb -> class::Root {
////	mappings.b2t->sum(m | m.nodes().block.cycles)
//	classes.Thread->
//}

//objective b2tcostb -> class::Thread {
//	classes.Block->sum(m | m.cycles) - mappings.b2t->filter(m | m.nodes().thread == self)->sum(m | m.nodes().block.cycles)
//}

global objective : min {
	intercomcost + f2tcost + glob * 100
//	glob
}

//global objective : max {
////	glob
//	to
//}
