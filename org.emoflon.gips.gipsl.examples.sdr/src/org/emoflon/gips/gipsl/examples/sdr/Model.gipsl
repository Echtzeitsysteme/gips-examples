package "org.emoflon.gips.gipsl.examples.sdr"
import "platform:/resource/org.emoflon.gips.gipsl.examples.sdrmodel/model/Sdrmodel.ecore"

config {  
	solver := GUROBI [home:="fu", license:="bar"];
	launchConfig := true [main := "TODO"];
	timeLimit := true [value := 30.0];
	randomSeed := true [value := 0];
	presolve := true;
	debugOutput := true;
}

rule block2thread {
	root: Root {
		-cpus -> cpu
		-jobs -> job
	}
	
	cpu: CPU {
		-cores -> core
		++ -guests -> job
	}
	
	// Also pins the job to a CPU
	job: Job {
		-blocks -> block
		++ -hosts -> cpu
	}
	
	core: Core {
		-threads -> thread
	}
	
	thread: Thread {
		++ -guests -> block
	}
	
	block: Block {
		++ -host -> thread
	}
	
//	# thread.processResource > 0
//	# thread.processResource >= block.processDemand
}

rule flow2intercom {
	root: Root {
		-cpus -> cpu
		-jobs -> job
	}
	
	cpu: CPU {
		-intercoms -> intercom
	}
	
	job: Job {
		-flows -> flow
	}
	
	flow: Flow {
		++ -host -> intercom
	}
	
	intercom: Interthreadcom {
		++ -flowGuests -> flow
	}
}

rule flow2thread {
		root: Root {
		-cpus -> cpu
		-jobs -> job
	}
	
	cpu: CPU {
		-cores -> core
	}
	
	job: Job {
		-flows -> flow
	}
	
	core: Core {
		-threads -> thread
	}
	
	flow: Flow {
		++ -host -> thread
	}
	
	thread: Thread {
		++ -flowGuests -> flow
	}
}

//
// GIPSL starts here!
//

mapping b2t with block2thread;
mapping f2i with flow2intercom;
mapping f2t with flow2thread;

// Every block must be mapped to a (=1) thread
constraint -> class::Block {
	mappings.b2t->filter(m | m.nodes().block == self)->count() == 1
}

//constraint -> class::Job {
//	mappings.b2t->filter(m | m.nodes().job == self)->count() == 1
//}

//// Thread process resources must not be over subscribed
//constraint -> class::Thread {
//	mappings.b2t->filter(m | m.nodes().thread == self)->sum(m | m.nodes().block.processDemand) <= self.processResource
//}

// Every flow must be mapped to an intercom or a thread
constraint -> class::Flow {
	mappings.f2i->filter(m | m.nodes().flow == self)->count() +
	mappings.f2t->filter(m | m.nodes().flow == self)->count()
	== 1
}

// Start and target of a flow must be embedded on its host counter parts (1, intercom)
constraint -> pattern::flow2intercom {
	mappings.b2t->filter(m | m.nodes().block == self.nodes().flow.source & m.nodes().thread == self.nodes().intercom.source)->count() +
	mappings.b2t->filter(m | m.nodes().block == self.nodes().flow.target & m.nodes().thread == self.nodes().intercom.target)->count()
	>= 2 * mappings.f2i->filter(m | m.nodes().intercom == self.nodes().intercom & m.nodes().flow == self.nodes().flow)->count()
}

// Start and target of a flow must be embedded on its host counter parts (2, thread)
constraint -> pattern::flow2thread {
	mappings.b2t->filter(m | m.nodes().block == self.nodes().flow.source & m.nodes().thread == self.nodes().thread)->count() +
	mappings.b2t->filter(m | m.nodes().block == self.nodes().flow.target & m.nodes().thread == self.nodes().thread)->count()
	>= 2 * mappings.f2t->filter(m | m.nodes().thread == self.nodes().thread & m.nodes().flow == self.nodes().flow)->count()
}

// Sanity check: All blocks must demand <= all threads resources
//constraint -> class::Job {
//	self.blocks->sum(b | b.processDemand) <= classes.Thread->sum(t | t.processResource)
//}

// Objective = inter-thread communication
objective intercomcost -> class::Interthreadcom {
//	mappings.f2i->filter(m | m.nodes().intercom == self)->sum(m | m.nodes().flow.rate)
	mappings.f2i->filter(m | m.nodes().intercom.source.core == m.nodes().intercom.target.core & m.nodes().intercom == self)->sum(m | m.nodes().flow.rate) * 1 +
	mappings.f2i->filter(m | m.nodes().intercom.source.core != m.nodes().intercom.target.core & m.nodes().intercom == self)->sum(m | m.nodes().flow.rate) * 3
}

// Each thread wants to minimize its used cycles
objective b2tcost -> class::Thread {
	mappings.b2t->filter(m | m.nodes().thread == self)->sum(m | m.nodes().block.cycles)
}

global objective : min {
	intercomcost + b2tcost
}
