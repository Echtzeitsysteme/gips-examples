import "platform:/resource/network.model/model/Model.ecore"
// you need a working iflye workspace to use this metamodel
// check out: https://github.com/Echtzeitsysteme/iflye

config {
	solver := GUROBI [home:="fu", license:="bar"];
	launchConfig := true [main := "org.emoflon.roam.roamslang.examples.mdvne.ExampleMdVNE"];
	timeLimit := true [value := 5.0];
	randomSeed := true [value := 42];
	presolve := true;
	debugOutput := true;
}

rule serverMatchPositive() {
	root: Root {
		-networks -> substrateNetwork
		-networks -> virtualNetwork
	}
	
	substrateServer: SubstrateServer {
		.residualCpu := substrateServer.residualCpu - virtualNode.cpu
		.residualMemory := substrateServer.residualMemory - virtualNode.memory
		.residualStorage := substrateServer.residualStorage - virtualNode.storage
		++ -guestServers -> virtualNode
	}
	
	virtualNode: VirtualServer {
		++ -host -> substrateServer
	}
	
	substrateNetwork: SubstrateNetwork {
		-nodes -> substrateServer
	}
	
	virtualNetwork: VirtualNetwork {
		-nodes -> virtualNode
	}
	
	# virtualNode.cpu <= substrateServer.residualCpu
	# virtualNode.memory <= substrateServer.residualMemory
	# virtualNode.storage <= substrateServer.residualStorage
}

rule switchNodeMatchPositive {
	root: Root {
		-networks -> substrateNetwork
		-networks -> virtualNetwork
	}
	
	substrateNode: SubstrateNode {
		++ -guestSwitches -> virtualSwitch
	}
	
	virtualSwitch : VirtualSwitch {
		++ -host -> substrateNode
	}
	
	substrateNetwork: SubstrateNetwork {
		-nodes -> substrateNode
	}
	
	virtualNetwork: VirtualNetwork {
		-nodes -> virtualSwitch
	}
}

rule linkPathMatchPositive {
	root: Root {
		-networks -> substrateNetwork
		-networks -> virtualNetwork
	}
	
	substratePath: SubstratePath {
		++ -guestLinks -> virtualLink
		.residualBandwidth := substratePath.residualBandwidth - virtualLink.bandwidth
		
		// Update all substrate links
		forEach links->l {
			iterator::l.residualBandwidth := iterator::l.residualBandwidth - virtualLink.bandwidth
		}
	}
	
	virtualLink: VirtualLink {
		++ -host -> substratePath
	}
	
	substrateNetwork: SubstrateNetwork {
		-paths -> substratePath
	}
	
	virtualNetwork: VirtualNetwork {
		-links -> virtualLink
	}
	
	# virtualLink.bandwidth <= substratePath.residualBandwidth
	
	// Explicitly exclude substrate paths with a residual bandwidth equals to 0
	# substratePath.residualBandwidth > 0
}

rule linkServerMatchPositive {
	root: Root {
		-networks -> substrateNetwork
		-networks -> virtualNetwork
	}
	
	substrateServer: SubstrateServer {
		++ -guestLinks -> virtualLink
	}
	
	virtualLink: VirtualLink {
		++ -host -> substrateServer
	}
	
	substrateNetwork: SubstrateNetwork {
		-nodes -> substrateServer
	}
	
	virtualNetwork: VirtualNetwork {
		-links -> virtualLink
	}
}

rule networkRule {
	root: Root {
		-networks -> substrateNetwork
		-networks -> virtualNetwork
	}
	
	substrateNetwork: SubstrateNetwork {
		++ -guests -> virtualNetwork
	}
	
	virtualNetwork: VirtualNetwork {
		++ -host -> substrateNetwork
	}
}

//
// RoamSLang starts here!
//

// TODO: Future work: Network embedding
//mapping net2net with networkRule;
////constraint -> class::VirtualNetwork {
////	self.nodes->filter(n | n.nodes().)->count() == 0
////}
//constraint -> match::networkRule {
////	mappings.srv2srv->filter(s | s.nodes().virtualServer == self.nodes().virtualNetwork.nodes)
//	self.nodes().virtualNetwork.nodes->filter(n | n == )
//}

// Server 2 Server
mapping srv2srv with serverMatchPositive;
constraint -> match::serverMatchPositive {
	mappings.srv2srv->filter(match | match.nodes().virtualNode == self.nodes().virtualNode)->count() == 1
}
objective srvObj -> mapping::srv2srv {
    self.nodes().substrateServer.residualCpu / self.nodes().substrateServer.cpu + 
    self.nodes().substrateServer.residualMemory / self.nodes().substrateServer.memory + 
    self.nodes().substrateServer.residualStorage / self.nodes().substrateServer.storage
//	self.nodes().substrateServer.residualCpu
	// TODO: ^breaks generated code
//	    self.nodes().substrateServer.residualCpu / self.nodes().substrateServer.cpu
}

constraint -> class::SubstrateServer {
	mappings.srv2srv->filter(match | match.nodes().substrateServer == self)->sum(match | match.nodes().virtualNode.cpu) <= self.residualCpu &
    mappings.srv2srv->filter(match | match.nodes().substrateServer == self)->sum(match | match.nodes().virtualNode.memory) <= self.residualMemory &
    mappings.srv2srv->filter(match | match.nodes().substrateServer == self)->sum(match | match.nodes().virtualNode.storage) <= self.residualStorage
}

// Switch 2 Node
mapping sw2node with switchNodeMatchPositive;
constraint -> match::switchNodeMatchPositive {
	mappings.sw2node->filter(match | match.nodes().virtualSwitch == self.nodes().virtualSwitch)->count() == 1
}

// Link 2 Path
mapping l2p with linkPathMatchPositive;
constraint -> match::linkPathMatchPositive {
	(mappings.srv2srv->filter(mpp | mpp.nodes().virtualNode == self.nodes().virtualLink.source & mpp.nodes().substrateServer == self.nodes().substratePath.source)->count() +
		mappings.sw2node->filter(mpp | mpp.nodes().virtualSwitch == self.nodes().virtualLink.source & mpp.nodes().substrateNode == self.nodes().substratePath.source)->count()) +
	(mappings.srv2srv->filter(mpp | mpp.nodes().virtualNode == self.nodes().virtualLink.target & mpp.nodes().substrateServer == self.nodes().substratePath.target)->count() +
		mappings.sw2node->filter(mpp | mpp.nodes().virtualSwitch == self.nodes().virtualLink.target & mpp.nodes().substrateNode == self.nodes().substratePath.target)->count())
	>= 2 * mappings.l2p->filter(mpp | mpp.nodes().substratePath == self.nodes().substratePath & mpp.nodes().virtualLink == self.nodes().virtualLink)->count()
//	mappings.srv2srv->filter(mpp | mpp.nodes().virtualNode == self.nodes().virtualLink.source & mpp.nodes().substrateServer == self.nodes().substratePath.source)->count() +
//	mappings.srv2srv->filter(mpp | mpp.nodes().virtualNode == self.nodes().virtualLink.target & mpp.nodes().substrateServer == self.nodes().substratePath.target)->count()
//	>= 2 * mappings.l2p->filter(mpp | mpp.nodes().substratePath == self.nodes().substratePath & mpp.nodes().virtualLink == self.nodes().virtualLink)->count()
}

//constraint -> match::linkPathMatchPositive {
////	mappings.l2p->filter(match | match.nodes().virtualLink == self.nodes().virtualLink)->count() +
////	mappings.l2s->filter(match | match.nodes().virtualLink == self.nodes().virtualLink)->count() == 1
//	mappings.l2p->filter(match | match.nodes().virtualLink == self.nodes().virtualLink)->count() == 1
//	// TODO: ^das hier lÃ¶st irgendwie den Fehler aus
//}
objective lpObj -> mapping::l2p {
	self.nodes().virtualLink.bandwidth * self.nodes().substratePath.hops
}

constraint -> class::SubstratePath {
	mappings.l2p->filter(match | match.nodes().substratePath == self)->sum(match | match.nodes().virtualLink.bandwidth) <= self.residualBandwidth
}

// Link 2 Server
mapping l2s with linkServerMatchPositive;
constraint -> match::linkServerMatchPositive {
//	mappings.srv2srv->filter(mpp | mpp.nodes().virtualNode == self.nodes().virtualLink.source & mpp.nodes().substrateServer == self.nodes().substrateServer)->count() +
//	mappings.sw2node->filter(mpp | mpp.nodes().virtualSwitch == self.nodes().virtualLink.source & mpp.nodes().substrateNode == self.nodes().substrateServer)->count() == 1 &
//	mappings.srv2srv->filter(mpp | mpp.nodes().virtualNode == self.nodes().virtualLink.target & mpp.nodes().substrateServer == self.nodes().substrateServer)->count() +
//	mappings.sw2node->filter(mpp | mpp.nodes().virtualSwitch == self.nodes().virtualLink.target & mpp.nodes().substrateNode == self.nodes().substrateServer)->count() == 1

	(mappings.srv2srv->filter(mpp | mpp.nodes().virtualNode == self.nodes().virtualLink.source & mpp.nodes().substrateServer == self.nodes().substrateServer)->count() +
		mappings.sw2node->filter(mpp | mpp.nodes().virtualSwitch == self.nodes().virtualLink.source & mpp.nodes().substrateNode == self.nodes().substrateServer)->count()) +
	(mappings.srv2srv->filter(mpp | mpp.nodes().virtualNode == self.nodes().virtualLink.target & mpp.nodes().substrateServer == self.nodes().substrateServer)->count() +
		mappings.sw2node->filter(mpp | mpp.nodes().virtualSwitch == self.nodes().virtualLink.target & mpp.nodes().substrateNode == self.nodes().substrateServer)->count())
	>= 2 * mappings.l2s->filter(mpp | mpp.nodes().substrateServer == self.nodes().substrateServer & mpp.nodes().virtualLink == self.nodes().virtualLink)->count()

//	mappings.srv2srv->filter(mpp | mpp.nodes().virtualNode == self.nodes().virtualLink.source & mpp.nodes().substrateServer == self.nodes().substrateServer)->count() +
//	mappings.srv2srv->filter(mpp | mpp.nodes().virtualNode == self.nodes().virtualLink.target & mpp.nodes().substrateServer == self.nodes().substrateServer)->count()
//	>= 2 * mappings.l2s->filter(mpp | mpp.nodes().substrateServer == self.nodes().substrateServer & mpp.nodes().virtualLink == self.nodes().virtualLink)->count()
}
	
//constraint -> match::linkServerMatchPositive {
//	mappings.l2s->filter(match | match.nodes().virtualLink == self.nodes().virtualLink)->count() +
//	mappings.l2p->filter(match | match.nodes().virtualLink == self.nodes().virtualLink)->count() == 1
//}

constraint -> class::VirtualLink {
	mappings.l2p->filter(m | m.nodes().virtualLink == self)->count() +
	mappings.l2s->filter(m | m.nodes().virtualLink == self)->count() == 1
//	mappings.l2p->filter(m | m.nodes().virtualLink == self)->count() == 1
}

// Global objective
global objective : min {
	srvObj + lpObj
}
