package "teachingassistant.kcl.gipssolution"
import "platform:/resource/teachingassistant.kcl.metamodel/model/Metamodel.ecore"

config {  
	solver := GUROBI;
	timeLimit := true [value := 120.0];
	randomSeed := true [value := 0];
	presolve := true;
	debugOutput := true;
}

//
// GT patterns and rules
//

// Assigns a teaching assistant to a tutorial.
//
// SkillType must match and the tutor's preference
// for this topic must at least be 1.
rule assignAssistantToTutorial {
	a : Assistant {
		- skills -> s
	}
	
	t : Tutorial {
		++ -givenBy -> a
	}
	
	d : Department {
		- assistants -> a
		- tutorials -> t
	}
	
	s : Skill
	
	// SkillType must match
	# t.skillType == s.name
	
	// preference must be at least 1
	# s.preference >= 1
}

// Pattern to find all possible combinations of
// assistants and times slots.
pattern findAssistantTimeslotTuple {
	d : Department {
		- assistants -> a
		- timeslots -> ts
	}
	a : Assistant
	ts : Timeslot
}

// Pattern to find possible tutorial content overlaps
// for an assistant `a`.
pattern findAssistantContentOverlap {
	d : Department {
		- assistants -> a
		- tutorials -> t1
		- tutorials -> t2
	}
	a : Assistant
	t1 : Tutorial
	t2 : Tutorial
	
	# t1.skillType == t2.skillType
}

// Finds assistant `a` that has the highest possible
// preference (2) for the tutorial `t`.
pattern findSkilledAssistant {
	d : Department {
		- assistants -> a
		- tutorials -> t
	}
	a : Assistant {
		- skills -> s
	}
	s : Skill
	t : Tutorial
	
	# s.preference == 2
	# s.name == t.skillType
}

// Find all possible combinations of lecturer `l`
// and assistant `a`.
pattern findLecturerAssistantTuple {
	d : Department {
		- lecturers -> l
		- assistants -> a
	}
	l : Lecturer
	a : Assistant
}

// Finds all possible combinations of assistant `a`,
// day `d`, and week `w`.
pattern findAssistantDayWeekTriple {
	dep : Department {
		- assistants -> a
		- days -> d
		- weeks -> w
	}
	a : Assistant
	d : Day {
		- week -> w
	}
	w : Week {
		- days -> d
	}
}

// Find all possible combinations of assistant `a`
// and week `w`.
pattern findAssistantWeekTuple {
	dep : Department {
		- assistants -> a
		- weeks -> w
	}
	a : Assistant
	w : Week
}

// ------------------------------

//
// GIPSL mappings
//

// Mapping to find and execute all teaching assistant assignments.
mapping at with assignAssistantToTutorial;

// Mapping that must be 1 if assistant `a` works for
// lecturer `l` (utility).
mapping laAssignment with findLecturerAssistantTuple;

// Mapping that must be 1 if assistant `a` works on
// day `d` (utility).
mapping adwAssignment with findAssistantDayWeekTriple;

// ------------------------------

//
// Constraints
//

// Every tutorial must be given exactly once.
constraint -> class::Tutorial {
	mappings.at->filter(m | m.nodes().t == self)->count() == 1
}

// The duration of *all* assignments for every assistant must lay
// in their time limit (`#assignments` <= `maxHoursTotal`).
constraint -> class::Assistant {
	mappings.at->filter(m | m.nodes().a == self)->sum(m | m.nodes().t.duration) <= self.maximumHoursTotal
}

// The duration of assignments per week for every assistant must lay
// in their weekly time limit (`minHoursPerWeek` <= `#hoursInWeek` <= `maxHoursPeerWeek`)
constraint -> pattern::findAssistantWeekTuple {
	mappings.at->filter( //
		m | m.nodes().a == self.nodes().a //
		& m.nodes().t.timeslot.day.week == self.nodes().w) //
		->sum(m | m.nodes().t.duration) //
	>= self.nodes().a.minimumHoursPerWeek
	
	&
	
	mappings.at->filter( //
		m | m.nodes().a == self.nodes().a //
		& m.nodes().t.timeslot.day.week == self.nodes().w) //
		->sum(m | m.nodes().t.duration) //
	<= self.nodes().a.maximumHoursPerWeek
}

// An assistant must not have two tutorials in the same time slot
// Formulation in GIPSL: for a given tuple of an Assistant `a` and a
// time slot `ts`, there must be at most one tutorial given by assistant
// `a` in time slot `ts`.
constraint -> pattern::findAssistantTimeslotTuple {
	mappings.at->filter(m | m.nodes().a == self.nodes().a & m.nodes().t.timeslot == self.nodes().ts)->count()
	<= 1
}

// If assistant a works for lecturer `l`, set its mapping variable
// to 1 (utility).
constraint -> pattern::findLecturerAssistantTuple {
	mappings.laAssignment->filter(m | m.nodes().a == self.nodes().a & m.nodes().l == self.nodes().l)->count() == 1
	<=>
	mappings.at->filter(m | m.nodes().a == self.nodes().a & m.nodes().t.lecturer == self.nodes().l)->count() >= 1
}

// Controlling the number of TAs for one course/lecturer
// Formulation in GIPSL: the number of assigned TAs for a given
// lecturer must be at most `maximumNumberOfTas`.
constraint -> class::Lecturer {
	mappings.laAssignment->filter(m | m.nodes().l == self)->count() <= self.maximumNumberOfTas
}

// If assistant `a` works on day `d` (in week `w`),
// set its mapping variable to 1 (utility).
constraint -> pattern::findAssistantDayWeekTriple {
	mappings.adwAssignment->filter(m | m.nodes().a == self.nodes().a & m.nodes().d == self.nodes().d)->count() == 1
	<=>
	mappings.at->filter(m | m.nodes().a == self.nodes().a & m.nodes().t.timeslot.day == self.nodes().d)->count() >= 1
}

// Controlling the number of days a TA works
// Formulation in GIPSL: the number of assigned days per week must be smaller 
// or equal to the number of maximum days per week (of the assistant).
constraint -> pattern::findAssistantWeekTuple {
	mappings.adwAssignment->filter( //
		m | m.nodes().a == self.nodes().a //
		& m.nodes().w == self.nodes().w //
	)->count() <= self.nodes().a.maximumDaysPerWeek
}

// ------------------------------

//
// Objectives
//

// Maximize the number of perfectly fitting assistants (skill type wise).
objective assistantSkillsObj -> pattern::findSkilledAssistant {
	mappings.at->filter(m | m.nodes().a == self.nodes().a & m.nodes().t == self.nodes().t)->count()
}

// Maximize the number of course content overlaps for each
// assistant, i.e., we want the tutorials on the same topics held
// by the same assistants if possible. This is equal to the maximization
// of overlapping triples (assistant `a`, tutorial `t1`, and tutorial `t2`
// which are both given by assistant `a`).
objective contentOverlapObj -> pattern::findAssistantContentOverlap {
	mappings.at->filter(m | m.nodes().a == self.nodes().a & m.nodes().t == self.nodes().t1)->count()
	+
	mappings.at->filter(m | m.nodes().a == self.nodes().a & m.nodes().t == self.nodes().t2)->count()
}

// Global objective that uses weights to prioritize the goals
// The constants are arbitrarily chosen.
global objective : max {
	// If possible, use assistants with highest skill
	1 * assistantSkillsObj
	+ 
	// Maximize topic overlap for each assistant
	0.5 * contentOverlapObj
}
