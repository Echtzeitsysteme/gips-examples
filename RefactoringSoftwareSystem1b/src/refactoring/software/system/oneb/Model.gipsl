package "refactoring.software.system.oneb"
import "platform:/resource/SoftwareSystem/model/softwareSystem.ecore"
import "http://www.eclipse.org/emf/2002/Ecore"

config {  
	solver := GUROBI [home:="fu", license:="bar"];
	timeLimit := true [value := 120.0];
	randomSeed := true [value := 0];
	presolve := true;
	debugOutput := true;
	tolerance := true [value := 0.00001];
}

//// Removes the `components` edge from a `System` to a `Component`.
//// This rule must be executed for every match before creating a new structure.
//rule removeComponentsEdge {
//	c: Component
//	s: System {
//		-- -components -> c
//	}
//	container : System {
//		++ -components -> c
//	}
//	# container.name == "container"
//}
//
//mapping removePreexistingEdges with removeComponentsEdge;
//
//// Every match of the rule `removeComponentsEdge` must be selected
//constraint -> mapping::removePreexistingEdges {
//	self.value() == 1
//}

// --------------------------------------------

rule componentToSystem {
	system : System {
		++ -components -> c
	}
	c : Component
}

rule system (assignments : EInt){
	s : System {
		.assignedComponents := param::assignments
	}
}

//pattern findGlobalInformation {
//	gi : GlobalInformation
//}

mapping c2s with componentToSystem;

mapping usedSystem with system {
	var assignments : EInt bind assignments
	var diff : EDouble
	var absDiff : EDouble
};

constraint -> mapping::usedSystem {
//	[self.variables().complexity >= 0.0001 => self.value() >= 1] &
//	[self.value() >= 1 => self.variables().complexity >= 0.0001 ] &
//	self.variables().complexity >= 0 &
	[self.variables().assignments >= 1 <=> self.value() >= 1] &
	self.variables().assignments >= 0 &
	self.variables().absDiff >= 0
}

constraint -> class::System {
	mappings.c2s->filter(m | m.nodes().system == self)->sum(m | m.value())
	==
	mappings.usedSystem->filter(m | m.nodes().s == self)->sum(m | m.variables().assignments)
}

constraint -> class::System {
	mappings.usedSystem->filter(m | m.nodes().s == self)->sum(m | m.variables().diff)
	==
	mappings.usedSystem->filter(m | m.nodes().s == self)->sum(m | m.variables().assignments)
	-
//	mappings.usedSystem->sum(m | m.variables().assignments) * patterns.findGlobalInformation->sum(fgi | fgi.nodes().gi.inversNumberOfSystems)
	mappings.usedSystem->sum(m | m.variables().assignments * m.nodes().s.inverseNumberOfSystems)
}

constraint -> mapping::usedSystem {
	[self.variables().diff >= 0 =>
	[self.variables().absDiff >= self.variables().diff & self.variables().absDiff <= self.variables().diff]] &
	
	[self.variables().diff <= -0.0001 =>
	[self.variables().absDiff >= (self.variables().diff * -1.0) & self.variables().absDiff <= (self.variables().diff * -1.0)]]
}

// Every component must be mapped to exactly one system
constraint -> class::Component {
	mappings.c2s->filter(m | m.nodes().c == self)->count() == 1
}

objective glob -> class::System {
	mappings.usedSystem->filter(m | m.nodes().s == self)->sum(m | m.variables().absDiff) * 1
}

global objective : min {
	glob
}
