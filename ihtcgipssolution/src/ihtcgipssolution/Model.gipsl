package "ihtcgipssolution"
import "platform:/resource/ihtcmetamodel/model/Ihtcmetamodel.ecore"

//
// Configuration
//

config {  
	solver := GUROBI;
	timeLimit := true [value := 300.0];
	randomSeed := true [value := 0];
	presolve := true;
	debugOutput := true;
	tolerance := true [value := 0.000001];
	threadCount := true [value := 4];
}

//
// GT
//

rule assignNurseToRoomShift {
	h : Hospital {
		- nurses -> n
		- shifts -> s
		- rooms -> r
	}
	
	n : Nurse {
		- shiftMaxLoads -> sml
	}
	
	s : Shift
	r : Room
	
	++ rsna : RoomShiftNurseAssignment {
		++ - nurse -> n
		++ - shift -> s
		++ - room -> r
	}
	
	sml : NurseShiftMaxLoad {
		- shift -> s
	}
	
	# sml.maxLoad > 0
}

rule assignAdmissionDayToPatient {
	h : Hospital {
		- patients -> p
		- days -> d
	}
	
	p : Patient {
		++ - admissionDay -> d
	}
	
	d : Day
	// TODO: it may be useful to add attribute constraint(s) to 
	// only include days which are within the patient's time frame
}

// H2: Compatible rooms: Patients can only be assigned to one of
// their compatible rooms
pattern roomPatientIncompatible {
	h : Hospital {
		- patients -> p
		- rooms -> r
	}
	
	p : Patient {
		- incompatibleRooms -> r
	}
	r : Room
}
condition roomNotIncompatible = forbid roomPatientIncompatible

rule assignRoomToPatient {
	h : Hospital {
		- patients -> p
		- rooms -> r
	}
	
	p : Patient {
		++ - assignedRoom -> r
	}
	
	r : Room
}
when roomNotIncompatible

rule assignSurgeryToPatient {
	h : Hospital {
		- patients -> p
		- surgeons -> s
		- days -> d
		- operatingTheaters -> ot
	}
	
	p : Patient {
		++ - surgeryAssignment -> sa
		- surgeon -> s
	}
	
	s : Surgeon {
		- availabilities -> as
	}
	
	d : Day
	ot : OperatingTheater {
		- availabilities -> aot
	}
	
	++ sa : SurgeryAssignment {
		++ - patient -> p
		++ - surgeon -> s
		++ - operationTheater -> ot
		++ - day -> d
	}
	
	aot : OperatingTheaterAvailability {
		- day -> d
	}
	# aot.availability > 0
	
	as : SurgeonAvailability {
		- day -> d
	}
	# as.availability > 0
}

pattern patientTuple {
	h : Hospital {
		- patients -> p1
		- patients -> p2
	}
	
	p1 : Patient
	p2 : Patient
}

pattern dayRoomTuple {
	h : Hospital {
		- days -> d
		- rooms -> r
	}
	
	d : Day
	r : Room
}

pattern daySurgeonTuple {
	h : Hospital {
		- days -> d
		- surgeons -> s	
	}
	
	d : Day
	s : Surgeon
}

pattern dayOperatingTheaterTuple {
	h : Hospital {
		- days -> d
		- operatingTheaters -> ot
	}
	
	d : Day
	
	ot : OperatingTheater {
		- availabilities -> aot
	}
	
	aot : OperatingTheaterAvailability
	# aot.availability > 0
}

pattern findMandatoryPatient {
	h : Hospital {
		- patients -> p
	}
	
	p : Patient
	
	# p.mandatory == true
}

//
// GIPSL
//

//
// Mappings
//

// Assign nurse to a room and shift
mapping anrs to assignNurseToRoomShift;

// Assign an admission day to a patient
mapping aadp to assignAdmissionDayToPatient;

// Assign a room to a patient
mapping arp to assignRoomToPatient;

// Assign a surgery to a patient
mapping asp to assignSurgeryToPatient;

//
// Constraints
//

// H1: No gender mix per room
constraint with patientTuple {
	[
		mappings.arp->filter(element.nodes.p == context.nodes.p1)->sum(element.value) == 1
		&
		mappings.arp->filter(element.nodes.p == context.nodes.p2)->sum(element.value) == 1
	]
	=>
	context.nodes.p1.gender == context.nodes.p2.gender
}

// H7: Room capacity: The number of patients in each room in each day cannot
// exceed the capacity of the room.
//constraint with dayRoomTuple {
//	// TODO: this can only be specified if the patient time frame mapping was done beforehand.
//}

// H3: Surgeon overtime: The maximum surgery time of a surgeon must not be exceeded.
constraint with daySurgeonTuple {
	// find variable assigned surgery time for a specific day and surgeon
	mappings.asp->filter( //
		element.nodes.d == context.nodes.d //
		& element.nodes.s == context.nodes.s
	)->sum(element.nodes.p.surgeryDuration * element.value)
	
	// must be smaller or equal to the surgeon's availability
	<=
	
	// get the surgeon's availability for the same specific day
	context.nodes.s.availabilities->filter(element.day == context.nodes.d)->sum(element.availability)
}

// H4: OT overtime: The duration of all surgeries allocated to an OT on a day
// must not exceed its maximum capacity.
constraint with dayOperatingTheaterTuple {
	// find variable assigned surgeries for a specific day and operating theater
	mappings.asp->filter( //
		element.nodes.d == context.nodes.d //
		& element.nodes.ot == context.nodes.ot //
	)->sum(element.nodes.p.surgeryDuration * element.value)
	
	// must be smaller of equal to the operating theater's maximum capacity
	<=
	
	// get the operating theater's capacity for the same specific day
	context.nodes.ot.availabilities->filter(element.day == context.nodes.d)->sum(element.availability)
}

// H5: Mandatory versus optional patients: All mandatory patients must be admitted within the
// scheduling period, whereas optional patients may be postponed to future scheduling periods.
//
// This constraint ensures that all mandatory patients get an admission day.
constraint with findMandatoryPatient {
	mappings.aadp->filter(element.nodes.p == context.nodes.p)->sum(element.value) == 1
}

// H6: Admission day: A patient can be admitted on any day from their release
// date to their due date. Given that optional patients do not have a due date,
// they can be admitted on any day after their release date.
//
// Part 1: A patient can be admitted on any day from their release date to their due date.
constraint with findMandatoryPatient {
	mappings.aadp->filter( //
		element.nodes.p == context.nodes.p //
		& element.nodes.d.id >= context.nodes.p.surgeryReleaseDay //
		& element.nodes.d.id <= context.nodes.p.surgeryDueDate //
	)->sum(element.value)
	== 1
}
